# Interpreter design
phi is a simple data language with just a little bit of programmability to it.
Transformations are driven by the _scope_, which is a list of rewrite rules.
Each rewrite rule is a pair of (parser, template), where the template is
rewritten with the binding list generated by the parser.

There are three data types:

1. `cons(x, y)`: a combination of two other values
2. `val(bytes)`: an immutable byte array
3. `ref`: an opaque, unique value

`ref` isn't technically necessary, but exists as a practical measure to make the
language faster and more secure. (The other option would be to have improbable
`val` values, which would effectively become interpreter keys.)

## Value properties
You can define more using rewrites, but the interpreter's bootstrap scope
assumes at least the following:

1. `abstract`/`constant`: whether the value can be rewritten
2. `type`: how to store the value, even if we can't compute it

These are computed quantities.

## Leaf nodes
A leaf node produces a runtime value, which can happen in a few ways. Going
through some examples:

```ocaml
let x = 1 + 2 + 3     (* 1 + 2 + 3 folds into 6, and x is a constant 6 *)
let x = f "foo"       (* f returns an abstract or constant of some type;
                         if timelined, then we sequence it *)
let x = open "file"   (* suppose "open" is a backend native; then it returns
                         a timelined abstract which we then sequence *)
```
