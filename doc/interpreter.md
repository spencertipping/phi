# Interpreter design
phi is a simple data language with just a little bit of programmability to it.
Transformations are driven by the _scope_, which is a list of rewrite rules.
Each rewrite rule is a pair of (parser, template), where the template is
rewritten with the binding list generated by the parser.

The only data structure is the cons cell. Everything else is implemented as a
primitive, of which there are two types:

- `val`: an immutable byte array with no particular semantics or interpretation
- `ref`: an immutable, opaque, unique value

Integers, strings, floats, etc are made from these values using type tagging.
The key is to use `ref`s to tag `val`s to assign meaning; for example:

- `string(bytes)` = `((instance_ref . string_type_ref) . bytes_val)`
- `int`   = `((instance_ref . int_type_ref) . int_bytes_val)`
- `float` = `((instance_ref . float_type_ref) . float_bytes_val)`

Because `ref`s are opaque, their only purpose is to provide variants. They are
deliberately impossible to serialize because their meaning is deliberately
limited to the hosting runtime.

**Q:** do we want a single `ref` object instead of a number of them? It's
unclear that we need more than one if they promote `val`s into that space.
(Actually this isn't true: having many is valuable because we never want
collisions, even across namespaces. The only way to guarantee that is to have
these values be opaque.)

## Value properties
You can define more using rewrites, but the interpreter's bootstrap scope
assumes at least the following:

1. `abstract`/`constant`: whether the value can be rewritten
2. `type`: how to store the value, even if we can't compute it
3. `timelines`: timelines against which the value needs to be synchronized (this
   list is empty for constants)

These are all computed quantities.

## Leaf nodes
A leaf node produces a runtime value, which can happen in a few ways. Going
through some examples:

```ocaml
let x = 1 + 2 + 3     (* 1 + 2 + 3 folds into 6, and x is a constant 6 *)
let x = f "foo"       (* f returns an abstract or constant of some type;
                         if timelined, then we sequence it *)
let x = open "file"   (* suppose "open" is a backend native; then it returns
                         a timelined abstract which we then sequence *)
```

Almost -- it's worth noting that `let x` forces the value for `x` immediately,
so although its _value_ is abstract, its timeline position is dictated by the
position of `let x`.

## Timeline sequencing
phi begins with a single timeline representing the runtime hosting the program.
Sequential statements get consed onto that timeline when they are (1) abstract,
and (2) indicate a dependency on it. Timeline state is stored in the scope, and
ultimately the timeline is the object that ends up being compiled or executed.

**Q:** if we're relying on timelines for execution, how do we handle recursive
functions and strict evaluation? It means `if` isn't a real function, or if it
is, it returns one of two lambdas. Or we don't inline through a forward
reference, but that seems arbitrary.

**Q:** if scopes are parsers that drive evaluation, do they resolve conditions
and/or forward references? Let's suppose they're graph parsers and forward
references get flattened into cyclic edges. Is this sufficient to unroll stuff?

Let's not worry about unrolling just yet. If the graph works correctly
otherwise, we won't need any particular special-casing.

## Sequential evaluation and exceptions
> Code can be compiled into a parser over result values; then we have sequences
> of operations that are executed and failover alt-paths for exception cases.
> I'm not 100% convinced we need to go that route, but it does provide a nice
> way to build in exception handling.

> (One potential issue is that we don't get a pure parse behavior because we're
> committing to timelines as we go, so we can't atomic-unwind.)

## Types
Types are phi refs, each of which is either `abstract` or `constant` for a given
node. Like any other phi value, types can be timeline-sequenced.

Abstract type values can be inspected as usual; most likely they'll be stalled
on conditions that haven't been folded down yet. This means it's usually
possible to construct a union or type bound.
