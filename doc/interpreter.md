# Interpreter design
phi is a simple data language with just a little bit of programmability to it.
Transformations are driven by the _scope_, which is a list of rewrite rules.
Each rewrite rule is a pair of (parser, template), where the template is
rewritten with the binding list generated by the parser.

There are two data types:

1. `cons(x, y)`: a combination of two other values
2. `string(bytes)`: a byte array

`nil` is the empty byte array. Each hosting runtime contains a 128-bit key that
provides special behavior; this is how gensyms work and avoid collisions. The
hosting scope is booted with a series of rewrites that detect the runtime key.

Runtimes can produce new keyed values, similar to `gensym`. There are a few of
these pre-reserved for some builtin semantic types:

- `iof`: the "instance of" operator, which marks a value as being of a type
- `int`: the integer type marker; the value is stored using bytes
- `string`: the string type marker; value is stored in bytes
- `symbol`: ...

**TODO:** enough stuff to write structural parsers

## Value properties
You can define more using rewrites, but the interpreter's bootstrap scope
assumes at least the following:

1. `abstract`/`constant`: whether the value can be rewritten
2. `type`: how to store the value, even if we can't compute it
3. `timelines`: timelines against which the value needs to be synchronized (this
   list is empty for constants)

These are all computed quantities.

## Leaf nodes
A leaf node produces a runtime value, which can happen in a few ways. Going
through some examples:

```ocaml
let x = 1 + 2 + 3     (* 1 + 2 + 3 folds into 6, and x is a constant 6 *)
let x = f "foo"       (* f returns an abstract or constant of some type;
                         if timelined, then we sequence it *)
let x = open "file"   (* suppose "open" is a backend native; then it returns
                         a timelined abstract which we then sequence *)
```

## Timeline sequencing
phi begins with a single timeline representing the runtime hosting the program.
Sequential statements get consed onto that timeline when they are (1) abstract,
and (2) indicate a dependency on it. Timeline state is stored in the scope, and
ultimately the timeline is the object that ends up being compiled or executed.

## Types
_Simple version:_ untagged monomorphic or tagged.

Types are phi refs, each of which is either `abstract` or `constant` for a given
node. Like any other phi value, types can be timeline-sequenced.

Abstract type values can be inspected as usual; most likely they'll be stalled
on conditions that haven't been folded down yet. This means it's usually
possible to construct a union or type bound.
