# Interpreter design
Despite my other docs, phi is a simple data language with just a little bit of
programmability to it. Transformations are driven by the _scope_, which is a
list of rewrite rules. Each rewrite rule is a pair of (parser, template), where
the template is rewritten with the binding list generated by the parser.

The only data structure is the cons cell. Everything else is implemented as a
primitive, of which there are two types:

- `val`: a byte array with no particular semantics or interpretation
- `ref`: an opaque and unique value

Integers, strings, floats, etc are made from these values using type tagging.
The key is to use `ref`s to tag `val`s to assign meaning; for example:

- `string(bytes)` = `((instance_ref . string_type_ref) . bytes_val)`
- `int`   = `((instance_ref . int_type_ref) . bytes_of_int)`
- `float` = `((instance_ref . float_type_ref) . bytes_of_float)`

This is beautiful.
