# Interpreter design
phi is a simple data language with just a little bit of programmability to it.
Transformations are driven by the _scope_, which is a list of rewrite rules.
Each rewrite rule is a pair of (parser, template), where the template is
rewritten with the binding list generated by the parser.

**TODO:** refactor below to have `cons`, `nil`, and `string`

The only data structure is the cons cell. Everything else is implemented as a
primitive, of which there are two types:

- `val`: an immutable byte array with no particular semantics or interpretation
- `ref`: an immutable, opaque, unique value

Integers, strings, floats, etc are made from these values using type tagging.
The key is to use `ref`s to tag `val`s to assign meaning; for example:

- `string(bytes)` = `((instance_ref . string_type_ref) . bytes_val)`
- `int`           = `((instance_ref . int_type_ref) . int_bytes_val)`

Because `ref`s are opaque, their only purpose is to provide variants. They are
deliberately impossible to serialize because we can't risk accidental
collisions, ever. IOW, `ref`s are designed to encapsulate local-scope value
hiding. If we really want to inspect/decode them, we can bind a decoder function
each time we create one.

Devil's advocate: how about we just create a UUID on startup, then append a
64-bit counter to that for each ref we want to create? Then we can live with
`cons`, `bytes`, and `nil`. This makes it possible to serialize, although not
semantically transfer, refs. If we send the scope, then we get semantic
transfer. Ok, this is a better system. Everything is either a cons or a string;
nil is the empty string.

## Value properties
You can define more using rewrites, but the interpreter's bootstrap scope
assumes at least the following:

1. `abstract`/`constant`: whether the value can be rewritten
2. `type`: how to store the value, even if we can't compute it
3. `timelines`: timelines against which the value needs to be synchronized (this
   list is empty for constants)

These are all computed quantities.

## Leaf nodes
A leaf node produces a runtime value, which can happen in a few ways. Going
through some examples:

```ocaml
let x = 1 + 2 + 3     (* 1 + 2 + 3 folds into 6, and x is a constant 6 *)
let x = f "foo"       (* f returns an abstract or constant of some type;
                         if timelined, then we sequence it *)
let x = open "file"   (* suppose "open" is a backend native; then it returns
                         a timelined abstract which we then sequence *)
```

## Timeline sequencing
phi begins with a single timeline representing the runtime hosting the program.
Sequential statements get consed onto that timeline when they are (1) abstract,
and (2) indicate a dependency on it. Timeline state is stored in the scope, and
ultimately the timeline is the object that ends up being compiled or executed.

## Types
_Simple version:_ untagged monomorphic or tagged.

Types are phi refs, each of which is either `abstract` or `constant` for a given
node. Like any other phi value, types can be timeline-sequenced.

Abstract type values can be inspected as usual; most likely they'll be stalled
on conditions that haven't been folded down yet. This means it's usually
possible to construct a union or type bound.
