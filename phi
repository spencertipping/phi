#!/usr/bin/env perl
# phi language interpreter

use strict;
use warnings;

package phi::parser::state::str
{
  sub new
  {
    my ($class, $string_ref, $offset) = @_;
    bless {string_ref => $string_ref,
           offset     => $offset || 0}, $class;
  }

  sub return
  {
    my ($self, $v, $consumed) = @_;
    bless {value      => $v,
           string_ref => $$self{string_ref},
           offset     => $$self{offset} + $consumed}, ref $self;
  }

  sub fail
  {
    my ($self, $error) = @_;
    bless {error      => $error,
           string_ref => $$self{string_ref},
           offset     => $$self{offset}}, ref $self;
  }

  sub next
  {
    my ($self, $n) = @_;
    substr ${$$self{string_ref}}, $$self{offset}, $n;
  }

  sub value { shift->{value} }
  sub error { shift->{error} }
}

package phi::parser::seq
{
  sub new
  {
    my ($class, @ps) = @_;
    bless \@ps, $class;
  }

  sub parse
  {
    local $_;
    my ($self, $s) = @_;
    my @states;
    $s->error ? return $s : push @states, $s = $_->parse($s) for @$self;
    $s->return([map $_->value, @states], 0);
  }
}

package phi::parser::alt
{
  sub new
  {
    my ($class, @ps) = @_;
    bless \@ps, $class;
  }

  sub parse
  {
    my ($self, $s) = @_;
    local $_;
    my $parsed;
    my @failed;
    ($parsed = $_->parse($s))->error ? push @failed, $parsed : return $parsed
      for @$self;
    $s->fail($self);
  }
}

package phi::parser::str
{
  sub new
  {
    my ($class, $s) = @_;
    bless \$s, $class;
  }

  sub parse
  {
    my ($self, $s) = @_;
    $s->next(length $$self) eq $$self
      ? $s->return($$self, length $$self)
      : $s->fail($self);
  }
}

package phi::parser::oneof
{
  sub new
  {
    my ($class, $chars) = @_;
    bless \$chars, $class;
  }

  sub parse
  {
    my ($self, $s) = @_;
    index($$self, $s->next(1)) == -1
      ? $s->fail($self)
      : $s->return($s->next(1), 1);
  }
}

package phi::parser::lookahead
{
  sub new
  {
    my ($class, $p) = @_;
    bless \$p, $class;
  }

  sub parse
  {
    my ($self, $s) = @_;
    my $next = $$self->parse($s);
    $s->error
      ? $s
      : $s->return($next->value, 0);
  }
}

package phi::parser::not
{
  sub new
  {
    my ($class, $p) = @_;
    bless \$p, $class;
  }

  sub parse
  {
    my ($self, $s) = @_;
    my $next = $$self->parse($s);
    $s->error
      ? $s->return(1, 0)
      : $s->fail($self);
  }
}

package phi::parser::repeat
{
  sub new
  {
    my ($class, $p, $min, $max) = @_;
    $min =  0 unless defined $min;
    $max = -1 unless defined $max;
    bless {parser => $p,
           min    => $min,
           max    => $max}, $class;
  }

  sub parse
  {
    my ($self, $s0) = @_;
    my $s = $s0;
    my @states;
    push @states, $s = $$self{parser}->parse($s) until $s->error;
    return $s->fail($self)
      unless @states >= $$self{min} and
             $$self{max} == -1 || @states <= $$self{max};
    return $s0 unless @states;
    $states[-1]->return([map $_->value, @states], 0);
  }
}

package phi::parser::map
{
  sub new
  {
    my ($class, $p, $f) = @_;
    bless {parser => $p,
           f      => $f}, $class;
  }

  sub parse
  {
    my ($self, $s) = @_;
    my $r = $$self{parser}->parse($s);
    $r->error
      ? $r
      : $r->return($$self{f}->($r->value), 0);
  }
}
