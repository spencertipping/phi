=head1 License
    phi programming language
    Copyright (C) 2018  Spencer Tipping

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
=cut

package phi;

use strict;
use warnings;

no warnings 'void';


=head2 phi compiler
L<phi0/classes.pm> defines the underlying machinery we use to generate bytecode
and other compiled outputs; now we need to put that stuff to work.

phi compilation is driven by classes, which are sort of macro assemblers of
their own. For example:

  class point
  {
    struct
    {
      int64 x;
      int64 y;
    };

    int64 x();
    int64 y();
    int64 x=(int64 x');
    int64 y=(int64 y');
  }

  protocol point_proto
  {
    int64 x();
    int64 y();
    int64 x=(int64 x');
    int64 y=(int64 y');
  }

  class vtable_polymorphic<point_proto>;

Now we can use these objects to generate code that operates on instances of
these classes. For example:

  asm                                   # destination[]
  lit64(polymorphic_point_proto_class)  # dest[] class_object
  "x=" swap .mcall                      # dest[.x=]

The resulting code is inlined into the asm object. Any C<mcall> instructions, if
they're necessary, are generated by the class. For monomorphic invocations they
typically aren't required:

  asm
  lit64(point_class)                    # this class is monomorphic
  "x=" swap .mcall                      # inlines the method (no mcall insn)

TODO: rethink this; it's fine to use an mcall insn for monomorphic methods if we
emit a constant for the vtable. Then we don't need to have the compiler inline
stuff, which is probably a good thing.
=cut


1;
