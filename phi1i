#!/usr/bin/env perl

=head1 License
    phi programming language
    Copyright (C) 2018  Spencer Tipping

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


=head1 phi boot image generator
This script emits a Linux/AMD64 machine code image. We aren't linked to any
libraries (including libc), so everything bottoms out in terms of system calls
and we aren't at all portable to other POSIX systems. This is an OK place to
start the world; later on we can specify how to build a C+JIT system that
interfaces to system functions using the standard C calling convention. The
image can then port itself to this backend.

Not all backends are low-level; we just start there because it's conveniently
minimalistic. phi can also recompile itself to languages like Javascript,
Python, Ruby, Perl, OCaml, Java, etc, each of which provides some form of GC
and/or OOP. phi is set up to delegate to hosting facilities when they're
available. (Optimizing effectively for each backend is another story that I'll
address within the phi codegen libraries.)
=cut

package phi;

use v5.14;          # required for pack() endian modifiers, // operator
use strict;
use warnings;

no warnings 'void';

BEGIN
{
  push @INC, $0 =~ s/\/[^\/]+$//r;
}


use constant DEBUG_TRACE_INSNS     => 0;
use constant DEBUG_ILLEGAL_INSNS   => 1;
use constant DEBUG_MISSING_METHODS => 1;

use phi0::image;                # perl -> phi memory allocations
use phi0::interpreter;
use phi0::oop;                  # perl -> phi classes

use phi1back::protocols;
use phi1front::protocols;

use phi1back::bytestring;
use phi1back::interpreter;
use phi1back::list;
use phi1back::map;
use phi1back::stringbuffer;

use phi1back::bytecode;
use phi1back::asm;
use phi1back::struct;           # phi1 -> phi1 data layout
use phi1back::oop;              # phi1 -> phi1 classes
use phi1back::flow;             # phi2 -> phi1 frame-aware semantics

use phi1front::parsers;
use phi1front::phi2;

use phi1back::reflection;       # NB: this always comes last

use phi0::genelf;

allocate_interpreter(heap);
allocate_machine_bootcode(heap);


# Load up the initial bytecode and generate a tempfile to execute it.
my $bytecode = join '', <ARGV>;
my $tempfile = "/tmp/phi1-$ENV{USER}-$$";

open my $fh, "> $tempfile"
  or die "failed to open $tempfile for writing: $!";
print $fh genelf $bytecode;
close $fh;
chmod 0755, $tempfile;

my $exit_code = system $tempfile;
unlink $tempfile;
exit $exit_code;
