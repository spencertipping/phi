#!/usr/bin/env perl

=head1 License
    phi programming language
    Copyright (C) 2018  Spencer Tipping

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


=head1 phi boot image generator
This script emits a Linux/AMD64 machine code image and runs it. We aren't linked
to any libraries (including libc), so everything bottoms out in terms of system
calls and we aren't at all portable to other POSIX systems. This is an OK place
to start the world; later on we can specify how to build a C+JIT system that
interfaces to system functions using the standard C calling convention. The
image can then port itself to this backend.

Not all backends are low-level; we just start there because it's conveniently
minimalistic. phi can also recompile itself to languages like Javascript,
Python, Ruby, Perl, OCaml, Java, etc, each of which provides some form of GC and
OOP. phi is set up to delegate to hosting facilities when they're available.
(Optimizing effectively for each backend is another story that I'll address
within the phi codegen libraries.)


=head2 How we're building this image
The simplest strategy is to start with Perl objects and then have each one mark
itself into the initial "heap", which in this case is just the ELF image.
Addresses are absolute and some references are circular, so there's a bit of
trickery involved to get the initial stuff set up correctly. Let's talk a little
about what our boot image is made of.

Ultimately we want to build up to a set of primitive machine code fragments that
can be strung together using C<cons> or other combination primitives, along with
a parser that puts them together by reading code from stdin. These fragments,
and really every piece of memory we allocate here, all need to be self-aware
objects because the garbage collector will likely end up relocating them. This
means they need vtables.

Ideally our image ends up being portable, meaning it can port itself to
different execution environments (some of which aren't AMD64 machine code). We
don't necessarily need each code fragment to specify each backend
implementation, but we do need some sort of semantic awareness at the fragment
level.

Basically, we need a FORTH that provides a Smalltalk-style object layer. Since
this requires garbage collection, we get a free promotion from FORTH to Joy --
but the internals still look a lot like stuff we'd do in FORTH.
=cut

package phi;

use v5.14;          # required for pack() endian modifiers, // operator
use strict;
use warnings;

use Carp;

BEGIN
{
  $Carp::Verbose = 1;
  $SIG{__DIE__} = sub { Carp::confess @_ };
}

no warnings 'void';


=head2 Object assembler
We could write the phi boot image in assembly language. The big advantage to
doing it in Perl is that we get better automation and finer control over the
exact machine instructions that get emitted. Both of these things matter a lot.

At a high level, here's what we need from an assembler interface:

1. Hex literal bytes
2. Octal literal bytes (mostly for ModR/M encoding)
3. Namespaced labels
4. Absolute positioning/addressing
5. C<pack> references to constants, relative labels, or absolute links

Everything ends up with an absolute address, so the linker can use the standard
two-pass design: allocate space first, then patch in the correct locations. We
don't have any addresses that change size, e.g. C<jmp label> in assembly; all of
the sizes are hard-coded up front and we do a quick overflow check to make sure
C<jmp short> (and other small-value) instructions are within range.


=head3 Authoring things
What we really need is something that behaves like a string but remains valid
(in the binary-linkage sense) even if we don't know the heap location of
everything up front. We should be able to insert C<pack> placeholders whose
values will later be computed, and we should also be able to easily grab a
pointer to any location within a string.

I think we want something like this:

  my $fn   = phi::asm->new->c3;
  my $code = phi::asm->new->e8pl($fn - right)->c3;

We first add everything to the heap; then once the addresses are set, the
objects can go back and patch themselves.
=cut


use constant left  => \"left";
use constant right => \"right";


package phi::asm
{
  use overload qw/ 0+ ptr /;

  sub new
  {
    bless { template => [],
            args     => [],
            location => undef }, shift;
  }

  sub locate       { $_[0]->{location} = $_[1]; shift }
  sub location     { shift->{location} }
  sub size         { length shift->unlinked }
  sub ptr          { phi::asm_ptr->new(shift) }

  sub unlinked     { shift->compile(sub { 0 }) }
  sub linked       { shift->compile(sub { shift->location }) }
  sub dependencies { grep ref, map @$_, @{shift->{args}} }

  sub safe_pack
  {
    # Identical to pack(), but verifies that none of the numeric args has
    # overflowed. We detect this by unpacking to make sure we reconstruct the
    # original list.
    my ($template, @xs) = @_;
    my $packed = pack $template, @xs;
    my @ys     = unpack $template, $packed;

    @xs == @ys or
      die "phi::asm: inconsistent element length for $template: $#xs vs $#ys";

    my $xs = join", ", @xs;
    my $ys = join", ", @ys;
    lc $xs eq lc $ys or
      die "phi::asm: inconsistent reconstruction for $template: [$xs] vs [$ys]";

    $packed;
  }

  sub compile
  {
    my ($self, $resolver) = @_;
    join"", map safe_pack($$self{template}[$_], map ref ? $resolver->($_) : $_,
                                                    @{$$self{args}[$_]}),
                0..$#{$$self{template}};
  }

  sub rewrite_left_right { shift }
  sub rewrite_here
  {
    my $self  = shift;
    my $left  = $self;
    my $right = $self->ptr + $self->size;
    map ref ? $_->rewrite_left_right($left, $right) : $_, @_;
  }

  sub append
  {
    my $self     = shift;
    my $template = shift;

    # First, stage the arguments so we can calculate the new unlinked size.
    push @{$$self{template}}, $template;
    push @{$$self{args}},     [@_];

    my @args = $self->rewrite_here(@_);

    # Now we have revised offsets for delta pointers, so replace the args we
    # just added with the rewritten ones.
    #
    # NB: this means you can't reliably refer to the RHS of things like
    # BER-encoeed integers, but that kinda makes sense.
    $$self{args}[-1] = \@args;
    $self;
  }

  sub hex { shift->append("H*", join"", @_) }
  sub oct { shift->append("C",  CORE::oct shift) }
  sub lit { shift->append("a*", shift) }

  # NB: we need to define this to prevent it from falling into AUTOLOAD
  sub DESTROY {}

  # Syntactic completion for a few types of methods depending on their pattern
  our $AUTOLOAD;
  sub AUTOLOAD
  {
    my $self   = shift;
    my $method = $AUTOLOAD =~ s/.*:://r;

    while (length $method)
    {
      next if $method =~ s/^_+//;

      $self->hex($1),      next if $method =~ s/^x?((?:[0-9a-fA-F]{2})+)//;
      $self->oct($1),      next if $method =~ s/^o([0-3][0-7]{2})//;
      $self->lit($method), last if $method =~ s/^q//;

      # Direct pack templates: force little-endian on all native integer types,
      # use R as a shorthand for the / repeat specifier.
      $self->append($method =~ s/([slqiSLQI])/$1\</gr
                            =~ s/R/\//gr
                            =~ s/_//gr,
                    @_), last
        if $method =~ s/^p//;

      # Important: die rather than looping forever
      die "phi::asm: failed to parse method snippet starting with $method "
        . "(original call was \"$AUTOLOAD\")";
    }
    $self;
  }
}


package phi::asm_ptr
{
  use Scalar::Util qw/refaddr/;
  use overload qw/ +  plus
                   -  minus
                   0+ location /;

  sub new
  {
    my ($class, $base, $delta, $scale) = @_;
    bless { base  => $base,
            delta => $delta // 0,
            scale => $scale // 1 }, $class;
  }

  sub plus  { __PACKAGE__->new(shift, shift,  1) }
  sub minus { __PACKAGE__->new(shift, shift, -1) }

  sub rewrite
  {
    my ($x, $l, $r) = @_;
    return $x unless ref $x;
      refaddr $x eq refaddr phi::left  ? $l
    : refaddr $x eq refaddr phi::right ? $r
    : $x;
  }

  sub rewrite_left_right
  {
    my ($self, $l, $r) = @_;
    __PACKAGE__->new(rewrite($$self{base},  $l, $r),
                     rewrite($$self{delta}, $l, $r),
                     $$self{scale});
  }

  sub location_of($)
  {
    my $x = shift;
    my $l = ref $x ? $x->location : $x;
    die "phi::asm_ptr: $x has no defined location" unless defined $l;
    $l;
  }

  sub location
  {
    my $self = shift;
    location_of($$self{base}) + $$self{scale} * location_of $$self{delta};
  }
}


=head2 Structs and classes
In phi terminology, "struct" refers to the physical layout of an object whereas
"class" refers to the object's protocol. The distinction here is that a class
_can_ use a struct as a storage backend, but doesn't necessarily have to (and in
languages that provide classes, there would be no sense in doing so).

Structs aren't always straightforward: we can have variable-length sections
within a single value, as we do with vtables and code fragments. We have to
commit to some length at allocation time, so an _instance_ of a struct has fixed
size, but the struct itself need not commit to any size for all instances.

Both structs and classes are "source" objects -- they aren't directly runnable,
but they can produce runnable things (vtables and code fragments if we're
targeting machine code). Let's get into how they're stored.


=head3 Structs in detail
Just like in C, a struct converts between a structured representation and a flat
binary layout. Conceptually this is simple; we can do it with this API:

  struct.offset("field") -> integer     # NB: this API is insufficient
  struct.sizeof("field") -> integer
  struct.marker()        -> code(struct* -> struct'*)

The challenge comes in when we have variable-offset fields. For example, suppose
we have a struct with two variable-length sections:

  struct key_value_pair
  {
    size_t key_size;
    size_t value_size;
    char   key[key_size];               # not valid C, but this is what we mean
    char   value[value_size];
  }

C can't encode this struct because it doesn't have a fixed size and C<value> has
a computed offset within it -- so C<&kv.value> isn't well-defined. But in
principle nothing stops phi from supporting this type of thing. We just need to
modify the struct API:

  struct.reader("field") -> code(struct* -> val)
  struct.writer("field") -> code((struct*, val) -> struct*)
  struct.marker()        -> code(struct* -> struct'*)

NB: pointer size/format/etc is determined by meta-structs, explained more below.

This new API has a couple of advantages:

1. It's more semantically correct: structs own storage, not just layout
2. We can introduce write barriers, which makes generational GC possible

More on this in the meta-struct section, because it's cooler than it sounds.


=head3 Primitives and pointers, philosophically speaking
Things like C<int32_t> aren't structs per se: they aren't aggregates of other
values. Let's get philosophical about what exactly C<int32_t>, C<char*>, and
C<myclass*> mean.

=head4 C<char*>
If I hand you something and tell you it's a C<char*>, you know a few things:

1. It's the size of any other pointer
2. You can dereference it and get a C<char> value
3. It points into mapped memory (let's assume)
4. The C<char> value has an identity specified by its location
5. The C<char> value doesn't itself refer to anything

(4) is important: if you copy the C<char> into a local variable, you won't catch
updates made by anyone else who has the pointer. So, perhaps counterintuitively,
C<*(&char) != char> from a semantic perspective.

=head4 C<int32_t>
If I tell you C<x> is an C<int32_t>, you also know a few things:

1. It's 32 bits
2. Those 32 bits should be interpreted as a signed native-endian integer
3. It's a value: it doesn't have any intrinsic identity
4. It doesn't point to anything, so it returns itself when GC-marked

(4) is implied by (3).

Technically endianness isn't specified with integer types, but doing anything
other than native would create a big performance hit for no particularly good
reason.

=head4 C<myclass*>
Let's suppose C<myclass> is a polymorphic base with multiple concrete
alternatives. Then we know:

1. We can interpret the pointer destination as a fixed struct to get a vtable
2. The referent doesn't have a fixed size
3. The referent may refer to other values, so GC should ask it to mark itself
4. We can call methods on the B<pointer>; the referent is structurally opaque
5. We can call any method specified by C<myclass>

(1), (4), and (5) collectively imply that we have some consistent calling
convention for polymorphic pointer-referenced objects. That is, the objects have
a monomorphic element to them despite being generally polymorphic. This is kind
of obvious, but I'm calling it out here because phi draws some lines differently
from languages like Java that completely hide the implementation from you. In
particular, you can create your own polymorphism-negotiation strategies and
pointer types. This makes it possible to implement stuff like xor-linked lists
and C<here> pointers in a garbage-collected environment.


=head3 Classes in detail
Here's the instance state for a class:

  struct                       data;
  unordered_map <symbol, code> methods;
  set           <protocol>     protocols;

NB: C<data> dictates where the vtable is stored; this ultimately determines the
calling convention for backends that don't provide one. Classes themselves don't
dictate the method calling convention.

Class objects provide just two methods:

  class.vtable() -> vtable*
  class.resolve(symbol method) -> code

Method resolution is managed by protocols:

  protocol.resolve(symbol method) -> int32

NB: you don't have to follow any specific convention for receiver addressing,
but it's common to have the top stack element be a pointer to the receiver.


=head3 Pointers, in practice
C has just one kind of pointer: the contract is that if you have a value of type
C<X*>, you can use the C<*> operator on it to get an lvalue of type C<X>.

Consider, though, how we would encode a C<here> pointer in C. We could use
C<void*>, but from a type perspective we have no indication that this is a
C<here> pointer at all. The only reason this works at all in C is that objects
don't move; but suppose they did. Then we'd need some pointer-level
polymorphism. We can get that in C++:

  template <class inner>
  struct pointer<inner>
  {
    inner* ref;
    inner*         deref() const { return ref; }
    pointer<inner> mark()        { return ref->mark(); }
  }

  template <class outer, class inner>
  struct here_pointer<outer, inner>
  {
    char* ptr;      // type doesn't matter; we just need sizeof() == 1
    inner* deref() const { return (inner*) ptr; }

    here_pointer<outer, inner> mark()
    {
      uint16_t  offset = ((uint16_t*) ptr)[-1];
      outer    *self   = (outer*) (ptr - offset);

      // NB: the offset is an intrinsic part of the here_pointer, so we need to
      // preserve it across GC
      return here_pointer((inner*) ((char*) ref->mark()->ptr + offset));
    }
  }

Note the lack of virtual methods here; most of the time phi treats pointers
monomorphically, just as C++ would if we used the classes above. When you want
polymorphism, you would have what amounts to a protocol-dispatch pointer:

  template <class T>
  struct polymorphic_pointer<T>
  {
    T* ptr;
    vtable<T>* vtable() const { return *((vtable<T>**) ptr); }
  }

The C<vtable()> method is where we encode the assumption that instances of C<T>
begin with a vtable pointer. There's no reason this needs to be true, though; we
could just as easily define a scheme where the vtable is an indirect int into a
class array, or located after the first eight bytes, or what have you. The only
real requirement is that anyone looking at the pointer be able to find the
vtable in some consistent way. This degree of consistency is the method-calling
convention.


=head3 Primitives, in practice
Primitives are often non-pointer values, e.g. C<int64>, C<double>. This is easy
to work with when they're referred to from within a structure; the GC will be
driven by type-aware C<mark()> methods.

The stack, on the other hand, is dynamically typed, so the GC won't know
how/when to mark things. We have a few options:

1. Use 128-bit (or >64-bit) stack entries by prepending a marker to each one
2. Convert things to use stack frames, and prepend those with markers
3. Use some type of pointer tagging (I don't like this)

Of these, (1) is the simplest option that doesn't involve float/int64 boxing. It
adds two operations to a push and one to a pop:

  # push %rax (original)                # push %rax (new)
  subq $8, %rsi                         movq %rax, *(%rsi - 8)
  movq %rax, *(%rsi)                    subq $16, %rsi
                                        xorq %rax, %rax
                                        movq %rax, *(%rsi)

  # pop into %rax (original)            # pop into %rax (new)
  lodsq                                 lodsq
                                        lodsq

There's no particular reason we need to use a full 8-byte marker per entry; in
all likelihood a single byte would suffice. (How many kinds of pointers are
there, really?) Then we'd have nine-byte stack entries like this:

  # push %rax                           # pop into %rax
  movq %rax, *(%rsi - 8)                lodsb
  subq $9, %rsi                         lodsq
  xorb %al, %al
  movb %al, *(%rsi)

In addition to saving runtime space, we also save a few bytes of code size:
C<lodsb> is one byte smaller than C<lodsq>, and C<xorb> and C<movb> both lack
the one-byte REX.W prefix.


=head3 Meta-structs, classes, and idiomatic backend integration
C<struct> is a protocol whose instances are called "meta-structs" -- this is
where we get things like vtable placement logic, padding for GC overhead, etc.
Some structs are backend-specific; for instance, C<perl_hash_struct> uses Perl
code to implement phi structs. This brings us to a new problem: what happens to
things like C<here> pointers of sub-structures in a world without flat memory
layout? Before I get into the specifics, I want to talk about a related problem:
idiomatic representation of things.

If we're targeting Javascript, we don't want to reduce things like strings to
flat byte arrays even if we have the machinery to do it. Instead, we want to use
the C<String> class when possible simply because it opens the door to seamless
integration with existing libraries. C<String> is idiomatic, so we prefer it.

Idioms vary a lot between languages and phi is in the relatively unenviable
position of bridging that gap. We do this with classes that are monomorphically
included as struct elements. Some of these classes are deliverately vague about
their underlying representation; these will become idiomatic quantities, much in
the way that Thrift/ProtoBuf schemas turn into idiomatic things. Other classes
are very specific and will fail to compile (or use strange implementations) on
backends that don't support them.

Putting this differently, phi lets you do what you probably want to do in every
language: you can write functions that generate and compile structs and classes,
and you can front-load the performance impact of doing this.


=head3 Method calling convention
I enumerated some possibilities for this in L<dev/e8.md>, but let's commit to
one:

  movq *%rsi, %rax                      # peek, don't pop
  movq *%rax, %rcx                      # load vtable
  call *(%rcx + 8*methodindex)          # call method

NB: we're not committing to the contents of C<%rax> or C<%rcx>; these are
scratch registers. Method implementations should use the data stack and
shouldn't assume anything about non-essential register contents.
=cut

sub phi::asm::mi
{
  # Call method at specified index (emits machine code)
  my $self = shift->x488bo006_488bo010_ff;
  my $mi   = 8 * shift;
  $mi < 128                             # NB: disp8 is signed
    ? $self->o121pc($mi)
    : $self->o221pl($mi);
}


=head2 Instructions and lists
phi's compiler consumes instruction lists and produces machine code fragments.
This is a fairly straightforward process because phi is concatenative: for the
most part, C<compile([x y ...]) == compile([x]) ++ compile([y]) ++ ...>.

Neither instructions nor cons cells have any intrinsic awareness of how they
would be represented in any given backend. The purpose of cons cells and
instruction objects is strictly to _describe_ a computation, not specify how it
should happen.

We can evaluate (not just compile) a list by pushing all of the tail elements
onto the return stack and returning normally:

  [f1 f2 f3].eval() -> push $f3; push $f2; push $f1; ret

This is nice because it means we don't hold a reference to the list object even
while we're evaluating it.

We don't always have direct access to the return stack, for instance in most
hosted environments. In those cases we can just run a normal loop.
=cut

# TODO


=head2 Classes and protocols
In a world with only classes, we'd need to allocate a separate vtable index for
every single method, which would take up a lot of space:

  # the world without protocols: every class contains four vtable entries
  class A {
    method foo;     # vtable index 0
    method bar;     # vtable index 1
  }
  class B {
    method foo;     # vtable index 0
    _               # vtable index 1 is blank to avoid A::bar conflict
    method bif;     # vtable index 2
    method baz;     # vtable index 3
  }

This is equivalent to every class belonging to a single protocol that contains
the union of everyone's methods.

We can fix this by specifying which classes are eligible for which virtual
method calls, in this case by adding them to a protocol object:

  protocol has_foo {
    method foo;     # same vtable index within all member classes
  }
  class A : has_foo {
    method foo;     # vtable index 0
    method bar;     # vtable index 1
  }
  class B : has_foo {
    method foo;     # vtable index 0
    method bif;     # vtable index 1 (no collision with A::bar)
    method baz;     # vtable index 2
  }

This is basically how method resolution works in statically-typed languages like
Java or C++; phi also uses static typing when it comes to classes/methods, it
just has more support for runtime code generation.

Every virtual method invocation, then, addresses a protocol rather than a class.
Any class-focused method invocations are static function calls and are likely to
be inlined during compilation.

NB: we can't modify vtables once they're allocated, so compiled classes,
vtables, and dynamic method calls are all immutable once you start using them.
It's theoretically possible to enumerate heap objects and rewrite their vtables
if all you're doing is adding new methods to things, but that's a library thing
instead of something built into the object system.
=cut

# TODO: implement stuff


=head2 Build the image
This is pretty simple: we just write the entire heap contents into a file and
call it a day. This works because the heap begins with ELF header allocations
that locate it properly in memory.


=head3 Debugging code
Let's write some macros to make life much much easier. Basically, we want to
have some things we can drop into machine code to tell us what's going on inside
the image. We don't have libc, so int->string and such are functions we'll have
to write for ourselves if we want them.
=cut

sub phi::asm::exit_constant
{
  shift->_4831o300_b03c         # %rax = 0x3c (exit syscall)
       ->_48c7o307_pl(shift)    # %rdi = $code (exit code)
       ->_0f05;                 # syscall -- no return from here
}

sub phi::asm::debug_print
{
  my ($asm, $message) = @_;
  $asm->_50_52_56_57            # push %rax, %rdx, %rsi, %rdi
      ->_4831o300_b001          # %rax (n) = 1 (write syscall)
      ->_e8pl(length $message)  # call sizeof(message)
      ->lit($message)           # the message
      ->_5e                     # pop &message -> %rsi (buf)
      ->_bapl(length $message)  # mov length -> %rdx (len)
      ->_48c7o307pl(1)          # %rdi (fd) = 1
      ->_0f05                   # syscall
      ->_5f_5e_5a_58;           # pop %rdi, %rsi, %rdx, %rax
}

use constant entry_point => phi::asm->new
  ->debug_print("image is ok\n")
  ->exit_constant(0);


=head3 ELF header
These behave like heap allocations because of page alignment. Basically, let's
say our virtual address space starts at 0x400000; because the ELF file is
memory-mapped rather than copied, we have the constraint that we can "move" the
file's contents only by increments of 4096 bytes -- whole pages. We can't assign
an arbitrary offset, e.g. to skip the ELF header.

This isn't much of a problem really. As far as phi is concerned, our initial
heap is maybe 120 bytes smaller than it would normally be because it's got some
mystery data (the ELF headers) prepended; then that will get garbage collected
because nothing refers into it. So the net impact of our ELF headers ends up
being zero, exactly what we want.
=cut

use constant elf_hdr => phi::asm->new
  ->pC16_SSL(
    0x7f, ord 'E', ord 'L', ord 'F',
    2, 1, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    2,                                  # e_type    = ET_EXEC
    62,                                 # e_machine = EM_X86_64
    1)                                  # e_version = EV_CURRENT
  ->pQ(entry_point)
  ->pQQ_LSS_SSSS(
    64,                                 # e_phoff
    0,                                  # e_shoff
    0,                                  # e_flags

    64,                                 # e_ehsize
    56,                                 # e_phentsize
    1,                                  # e_phnum

    0,                                  # e_shentsize
    0,                                  # e_shnum
    0)                                  # e_shstrndx
  ->pLLQQQQQQ(
    1,                                  # p_type = PT_LOAD
    7,                                  # p_flags = R|W|X (important)
    0,                                  # p_offset (must be page-aligned)
    0x400000,                           # p_vaddr
    0,                                  # p_paddr
    0x1000,                             # p_filesz
    0x1000,                             # p_memsz
    0x1000);                            # p_align


=head3 Heap construction
Allocate everything into the heap, dependencies last. C<elf_hdr> must be the
first object we allocate in order to generate a valid executable.
=cut

my @heap;
for (my ($offset, @objects) = (0x400000, elf_hdr);
     @objects;)
{
  my $o = shift @objects;
  unless (defined $o->location)
  {
    push @heap, $o;
    $o->locate($offset);
    $offset += $o->size;
    push @objects, $o->dependencies;
  }
}


open my $fh, "> phi";
print $fh join"", map $_->linked, @heap;
close $fh;

chmod 0755, "phi";
