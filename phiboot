#!/usr/bin/env perl

=head1 License
    phi programming language
    Copyright (C) 2018  Spencer Tipping

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


=head1 phi boot image generator
This script emits a Linux/AMD64 machine code image and runs it. We aren't linked
to any libraries (including libc), so everything bottoms out in terms of system
calls and we aren't at all portable to other POSIX systems. This is an OK place
to start the world; later on we can specify how to build a C+JIT system that
interfaces to system functions using the standard C calling convention. The
image can then port itself to this backend.

Not all backends are low-level; we just start there because it's conveniently
minimalistic. phi can also recompile itself to languages like Javascript,
Python, Ruby, Perl, OCaml, Java, etc, each of which provides some form of GC and
OOP. phi is set up to delegate to hosting facilities when they're available.
(Optimizing effectively for each backend is another story that I'll address
within the phi codegen libraries.)


=head2 How we're building this image
The simplest strategy is to start with Perl objects and then have each one mark
itself into the initial "heap", which in this case is just the ELF image.
Addresses are absolute and some references are circular, so there's a bit of
trickery involved to get the initial stuff set up correctly. Let's talk a little
about what our boot image is made of.

Ultimately we want to build up to a set of primitive machine code fragments that
can be strung together using C<cons> or other combination primitives, along with
a parser that puts them together by reading code from stdin. These fragments,
and really every piece of memory we allocate here, all need to be self-aware
objects because the garbage collector will likely end up relocating them. This
means they need vtables.

Ideally our image ends up being portable, meaning it can port itself to
different execution environments (some of which aren't AMD64 machine code). We
don't necessarily need each code fragment to specify each backend
implementation, but we do need some sort of semantic awareness at the fragment
level.

Basically, we need a FORTH that provides a Smalltalk-style object layer. Since
this requires garbage collection, we get a free promotion from FORTH to Joy --
but the internals still look a lot like stuff we'd do in FORTH.
=cut

package phi;

use v5.14;          # required for pack() endian modifiers, // operator
use strict;
use warnings;


=head2 Writing machine code
The Intel guys didn't make things easy. Instructions are a mixture of hex and
octal, and at irregular locations. I'm going to write a little function to take
mixed hex/octal and pack it into a binary string, for instance:

  b"4831o300"

You can also specify percent-prefixed C<pack> things for extra args:

  b"48b8 %Q<", $x

You can use ni and ndisasm to check commands:

  $ sudo apt install nasm
  $ ni pRphiboot 1p'wp "a*" => phi::b "4831 o300"' e[ndisasm -b 64 -]

=cut

sub b
{
  my ($format, @args) = @_;
  join"", map s/^%// ? pack($_, shift @args // die "b($format): too few args")
                     : map(pack(C => $_),
                           map s/^o// ? oct : hex, /o[0-7]{3}|[0-9a-fA-F]{2}/g),
              split /(%\w[<>]?)/, $format;
}


=head2 Structs
In phi terminology, "struct" refers to the physical layout of an object whereas
"class" refers to the object's protocol. The distinction here is that a class
_can_ use a struct as a storage backend, but doesn't necessarily have to (and in
languages that provide classes, there would be no sense in doing so).

Structs aren't always straightforward: we can have variable-length sections
within a single value, as we do with vtables and code fragments. We have to
commit to some length at allocation time, so an _instance_ of a struct has fixed
size, but the struct itself need not commit to any size for all instances.
=cut

package phi::struct
{
  # TODO
}


=head2 Code objects
TODO: fix this section; how do we include multiple languages in the same object?

If vtables point to machine code, how do we recompile a method? Machine code is
basically opaque from a parsing point of view (as it should be; I don't really
want to get into the CPU emulation market).

Well, just like we do with vtables, code pointers refer to an offset within each
object:

            vtable pointers refer to this offset,
            not to the beginning of the code fragment object
                                                           |
                                                           V
  <8-byte vtable pointer> <source> <linkage> <size> <here> <code...>

NB: C<here> is something you'll see anytime we have pointers to the middle of a
structure. It's an unsigned two-byte int that specify how far into the struct
you are, which makes it possible to have middle-pointers into polymorphic
objects. The contract is that C<< &(struct.here) - &struct == struct.here >>;
that is, its value is its offset.

Q: how do we simulate C<here> in other backends? Probably store a compound
pointer: C<(object, index)> that we use with a helper method to dereference. So
inner pointers work like arrays, basically.

The object itself contains a pointer to a C<source> object, which is a semantic
description of what the code does. More specifically, C<source> points to a list
of backend-neutral instructions; it's enough information to fully reproduce the
compiled code object (possibly in another backend).

C<linkage> points to an object that describes the location of any absolute
references within C<code>; we need this so we can quickly rewrite those
addresses when we GC-mark and move the code fragment.

NB: code fragments almost always end in C<c3>, which is a C<ret> instruction.
This byte is omitted when we inline a fragment.
=cut

package phi::code
{
  # TODO
}


=head2 vtables
Let's start here. vtables are the compiled form of classes, and they specify the
implementation of numerically-defined methods against objects. So an object
looks like this:

  <8-byte vtable pointer> <instance data>

...and the vtable looks like this:

     object vtable pointers refer here,
     not to the beginning of the vtable object
                                             |
                                             V
  <8-byte vtable pointer> <class> <n> <here> <codeptr1> ... <codeptrN>

This supports our calling convention: we can call-indirect into any C<codeptr>
with the receiver on the data stack.
=cut

package phi::vtable
{
  # TODO
}


=head2 Method calling convention
I enumerated some possibilities for this in L<dev/e8.md>, but let's commit to
one:

  movq *%rsi, %rax                      # peek, don't pop
  movq *%rax, %rcx                      # load vtable
  call *(%rcx + 8*methodindex)          # call method

NB: we're not committing to the contents of C<%rax> or C<%rcx>; these are
scratch registers. Method implementations should use the data stack and
shouldn't assume anything about non-essential register contents.
=cut

sub mi($)
{
  # Call method at specified index (returns machine code)
  my $mi = 8 * shift;
  $mi < 128                             # NB: disp8 is signed
    ? b"488bo006 488bo010 ffo121 %c", $mi
    : b"488bo006 488bo010 ffo221 %l<", $mi;
}


=head2 Instructions and cons cells
phi's compiler consumes instruction lists and produces machine code fragments.
This is a fairly straightforward process because phi is concatenative: for the
most part, C<compile([x y ...]) == compile([x]) ++ compile([y]) ++ ...>.

Neither instructions nor cons cells have any intrinsic awareness of how they
would be represented in any given backend. The purpose of cons cells and
instruction objects is strictly to _describe_ a computation, not specify how it
should happen.

Not all lists back into cons cells. At first I thought I had to, but C<here>
markers make it possible to have multi-element lists that can be addressed
properly. For example:

  ... <here> <f1> <here> <f2> ... <here> <fN>

We can refer to any function here and still recover the whole list, so we're
GC-safe.
=cut




=head2 Heap simulator
We're generating the image by allocating stuff into the initial memory-mapped
heap, so let's define a heap object that manages some of the bookkeeping for us.
=cut

package phi::heap
{
  sub new
  {
    my ($class, $initial_address) = @_;
    bless { allocations => [],
            offset      => $initial_address }, $class;
  }

  sub allocate
  {
    use bytes;
    my ($self, $x) = @_;
    my $location = $$self{offset};
    push @{$$self{allocations}}, $x;
    $$self{offset} += length $x;
    $location;
  }

  sub size
  {
    my ($self, $size) = ($_[0], 0);
    $size += length for @{$$self{allocations}};
    $size;
  }
}


=head2 Classes and protocols
In a world with only classes, we'd need to allocate a separate vtable index for
every single method, which would take up a lot of space:

  # the world without protocols: every class contains four vtable entries
  class A {
    method foo;     # vtable index 0
    method bar;     # vtable index 1
  }
  class B {
    method foo;     # vtable index 0
    _               # vtable index 1 is blank to avoid A::bar conflict
    method bif;     # vtable index 2
    method baz;     # vtable index 3
  }

This is equivalent to every class belonging to a single protocol that contains
the union of everyone's methods.

We can fix this by specifying which classes are eligible for which virtual
method calls, in this case by adding them to a protocol object:

  protocol has_foo {
    method foo;     # same vtable index within all member classes
  }
  class A : has_foo {
    method foo;     # vtable index 0
    method bar;     # vtable index 1
  }
  class B : has_foo {
    method foo;     # vtable index 0
    method bif;     # vtable index 1 (no collision with A::bar)
    method baz;     # vtable index 2
  }

This is basically how method resolution works in statically-typed languages like
Java or C++; phi also uses static typing when it comes to classes/methods, it
just has more support for runtime code generation.

Every virtual method invocation, then, addresses a protocol rather than a class.
Any class-focused method invocations are static function calls and are likely to
be inlined during compilation.

NB: we can't modify vtables once they're allocated, so compiled classes,
vtables, and dynamic method calls are all immutable once you start using them.
It's theoretically possible to enumerate heap objects and rewrite their vtables
if all you're doing is adding new methods to things, but that's a library thing
instead of something built into the object system.
=cut

# TODO: implement stuff


=head2 ELF assembly
The final step.
=cut

use constant ehdr => pack 'C16 SSL QQQ LSS SSSS',
  0x7f, ord 'E', ord 'L', ord 'F',
  2, 1, 1, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,

  2,                                    # e_type    = ET_EXEC
  62,                                   # e_machine = EM_X86_64
  1,                                    # e_version = EV_CURRENT

  0x400078,                             # e_entry
  64,                                   # e_phoff
  0,                                    # e_shoff
  0,                                    # e_flags

  64,                                   # e_ehsize
  56,                                   # e_phentsize
  1,                                    # e_phnum

  0,                                    # e_shentsize
  0,                                    # e_shnum
  0;                                    # e_shstrndx

use constant phdr => pack 'LLQQQQQQ',
  1,                                    # p_type = PT_LOAD
  7,                                    # p_flags = R|W|X (important)
  0,                                    # p_offset (must be page-aligned)
  0x400000,                             # p_vaddr
  0,                                    # p_paddr
  0x1000,                               # p_filesz
  0x1000,                               # p_memsz
  0x1000;                               # p_align

use constant code => "\xe9" . pack l => -5;

# Do nothing if we're being included as a library (this makes it possible for ni
# to include this as a perl module)
unless (caller)
{
  open my $fh, "> phi";
  print $fh join"", ehdr, phdr, code;
  close $fh;

  chmod 0700, "phi";

  exec "./phi";
}
else
{
  1;
}
