#!/usr/bin/env perl

=head1 License
    phi programming language
    Copyright (C) 2018  Spencer Tipping

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


=head1 phi boot image generator
This script emits a Linux/AMD64 machine code image. We aren't linked to any
libraries (including libc), so everything bottoms out in terms of system calls
and we aren't at all portable to other POSIX systems. This is an OK place to
start the world; later on we can specify how to build a C+JIT system that
interfaces to system functions using the standard C calling convention. The
image can then port itself to this backend.

Not all backends are low-level; we just start there because it's conveniently
minimalistic. phi can also recompile itself to languages like Javascript,
Python, Ruby, Perl, OCaml, Java, etc, each of which provides some form of GC
and/or OOP. phi is set up to delegate to hosting facilities when they're
available. (Optimizing effectively for each backend is another story that I'll
address within the phi codegen libraries.)
=cut

package phi;

use v5.14;          # required for pack() endian modifiers, // operator
use strict;
use warnings;
no warnings 'void';

use Carp;

BEGIN
{
  $Carp::Verbose = 1;
  $SIG{__DIE__} = sub { Carp::confess @_ };
}


=head2 General build/debug settings
We want to be able to inspect various aspects of phi's behavior quickly, so I've
built in a bunch of conditional build settings that compile debug tracers into
the image if we need them.
=cut

use constant TRACE_INSNS => 0;


=head2 Object assembler
We could write the phi boot image in assembly language. The big advantage to
doing it in Perl is that we get better automation and finer control over the
exact machine instructions that get emitted. Both of these things matter a lot.

At a high level, here's what we need from an assembler interface:

1. Hex literal bytes
2. Octal literal bytes (mostly for ModR/M encoding)
3. Namespaced labels
4. Absolute positioning/addressing
5. C<pack> references to constants, relative labels, or absolute links

Everything ends up with an absolute address, so the linker can use the standard
two-pass design: allocate space first, then patch in the correct locations. We
don't have any addresses that change size, e.g. C<jmp label> in assembly; all of
the sizes are hard-coded up front and we do a quick overflow check to make sure
C<jmp short> (and other small-value) instructions are within range.


=head3 Authoring things
What we really need is something that behaves like a string but remains valid
(in the binary-linkage sense) even if we don't know the heap location of
everything up front. We should be able to insert C<pack> placeholders whose
values will later be computed, and we should also be able to easily grab a
pointer to any location within a string.

I think we want something like this:

  my $fn   = asm->c3;
  my $code = asm->e8pl($fn - right)->c3;

We first add everything to the heap; then once the addresses are set, the
objects can go back and patch themselves.
=cut


sub left();
sub right();
sub phi::asm(;$);
sub phi::l($);


sub location_of
{
  my ($x, $asm) = @_;
  my $l = ref $x ? $x->location($asm) : $x;
  die "$x has no defined location" unless defined $l;
  $l;
}


package phi::asm
{
  # Shorthand: asm->... instead of phi::asm->new->...
  sub phi::asm(;$) { phi::asm::->new(shift) }

  our %all_located;

  use overload qw/ 0+ ptr "" linked << inline /;

  BEGIN { ++$INC{'phi/asm.pm'} }

  sub new
  {
    my ($class, $name) = @_;
    bless { template => [],
            args     => [],
            labels   => {},
            name     => $name,
            location => undef }, $class;
  }

  sub named      { $_[0]->{name} = $_[1]; shift }
  sub is_located { defined shift->{location} }
  sub size       { length shift->unlinked }
  sub ptr        { phi::asm_ptr->new(shift) }
  sub rptr       { phi::asm_ptr->new($_[0], $_[0]->size, 1) }

  sub locate
  {
    my ($self, $l) = @_;
    die $self->name . " is already located at $$self{location} (requested $l)"
      if defined $$self{location} && $$self{location} != $l;
    $$self{location} = $l;
    $all_located{$self->name} = $self if defined $$self{name};
    $self;
  }

  sub name
  {
    my $self = shift;
    $$self{name} // "anonymous[" . join(" ", @{$$self{template}}) . "]";
  }

  sub location
  {
    my $self = shift;
    $$self{location} // die "unallocated asm object " . $self->name;
  }

  sub dependencies { grep ref, map @$_, @{shift->{args}} }
  sub unlinked     { shift->compile(sub { 0 }) }
  sub linked
  {
    my $self = shift;
    die "cannot link unallocated asm object " . $self->name
      unless $self->is_located or !$self->dependencies;
    $self->compile(sub { shift->location($self) });
  }

  sub link_at
  {
    # Link in this object and all unallocated dependencies (transitively),
    # returning a flat memory allocation.
    my ($self, $location) = @_;
    die "link_at: moving already-located object " . $self->name . " from "
      . "$$self{location} to $location"
      if $self->is_located && $self->location != $location;

    $self->locate($location);
    my $asm = phi::asm->locate($location);
    $location += $self->size;

    # Record all labels into the location list
    if (defined $$self{name})
    {
      $all_located{$self->name . "/$_"} = $self->resolve($_)
        for keys %{$$self{labels}};
    }

    my @linked;

    for ($self->dependencies)
    {
      next if $_->is_located;
      push @linked, $_ = $_->link_at($location);
      $location += $_->size;
    }

    $asm->lit($_->linked) for $self, @linked;
    $asm;
  }

  sub safe_pack
  {
    # Identical to pack(), but verifies that none of the numeric args has
    # overflowed. We detect this by unpacking to make sure we reconstruct the
    # original list.
    my ($template, @xs) = @_;
    my $packed = pack $template, @xs;
    my $xs = join", ", @xs;
    my $ys = join", ", unpack $template, $packed;
    lc $xs eq lc $ys or
      die "phi::asm: inconsistent reconstruction for $template: [$xs] vs [$ys]";

    $packed;
  }

  sub compile
  {
    my ($self, $resolver) = @_;
    join"", map safe_pack($$self{template}[$_], map ref ? $resolver->($_) : $_,
                                                    @{$$self{args}[$_]}),
                0..$#{$$self{template}};
  }

  sub rewrite_left_right { shift }
  sub rewrite_here
  {
    my $self  = shift;
    my $left  = shift;
    my $right = $self->rptr;
    map ref ? $_->rewrite_left_right($left, $right) : $_, @_;
  }

  sub append
  {
    my $self     = shift;
    my $template = shift;
    my $left     = $self->rptr;

    # First, stage the arguments so we can calculate the new unlinked size.
    push @{$$self{template}}, $template;
    push @{$$self{args}},     [@_];

    my @args = $self->rewrite_here($left, @_);

    # Now we have revised offsets for delta pointers, so replace the args we
    # just added with the rewritten ones.
    #
    # NB: this means you can't reliably refer to the RHS of things like
    # BER-encoeed integers, but that kinda makes sense.
    $$self{args}[-1] = \@args;
    $self;
  }

  sub hex { shift->append("H*", join"", @_) }
  sub oct { shift->append("C",  CORE::oct shift) }
  sub lit { shift->append("a*", shift) }

  sub inline
  {
    my ($self, $asm) = @_;
    $asm = $asm->link_at($self->rptr->location) if $self->is_located;
    $self->append("a*", $asm->linked);
  }

  sub label
  {
    my ($self, $name) = @_;
    die "redefining label $name" if exists $$self{labels}{$name};
    $$self{labels}{$name} = $self->rptr;
    $self;
  }

  sub resolve
  {
    my ($self, $label) = @_;
    $$self{labels}{$label} // die $self->name . ": undefined label $label";
  }

  # NB: we need to define this to prevent it from falling into AUTOLOAD
  sub DESTROY {}

  # Syntactic completion for a few types of methods depending on their pattern
  our $AUTOLOAD;
  sub AUTOLOAD
  {
    my $self   = shift;
    my $method = $AUTOLOAD =~ s/.*:://r;

    while (length $method)
    {
      next if $method =~ s/^_+//;

      $self->hex($1),        next if $method =~ s/^x?((?:[0-9a-fA-F]{2})+)//;
      $self->oct($1),        next if $method =~ s/^o([0-3][0-7]{2})//;
      $self->lit($method),   last if $method =~ s/^q//;
      $self->label($method), last if $method =~ s/^l//;

      # Direct pack templates: force little-endian on all native integer types,
      # use R as a shorthand for the / repeat specifier.
      $self->append($method =~ s/([slqiSLQI])/($1\<)/gr
                            =~ s/R/\//gr
                            =~ s/_//gr,
                    @_), last
        if $method =~ s/^p//;

      die "phi::asm: failed to parse method snippet starting with $method "
        . "(original call was \"$AUTOLOAD\")";
    }
    $self;
  }
}


package phi::asm_ptr
{
  use Scalar::Util qw/refaddr/;
  use overload qw| +  plus
                   -  minus
                   *  times
                   /  over
                   0+ location |;

  BEGIN { ++$INC{'phi/asm_ptr.pm'} }

  sub new
  {
    my ($class, $base, $delta, $scale) = @_;
    bless { base  => $base,
            delta => $delta // 0,
            scale => $scale // 1 }, $class;
  }

  sub size  { 0 }

  sub plus  { phi::asm_ptr->new(shift, shift,  1) }
  sub minus { phi::asm_ptr->new(shift, shift, -1) }
  sub times { phi::asm_ptr->new(0, shift,   shift) }
  sub over  { phi::asm_ptr->new(0, shift, 1/shift) }

  sub rewrite
  {
    my ($x, $l, $r) = @_;
    return $x unless ref $x;
      refaddr $x eq refaddr phi::left  ? $l
    : refaddr $x eq refaddr phi::right ? $r
    : $x;
  }

  sub rewrite_left_right
  {
    my ($self, $l, $r) = @_;
    phi::asm_ptr->new(rewrite($$self{base},  $l, $r),
                      rewrite($$self{delta}, $l, $r),
                      $$self{scale});
  }

  sub is_located   { not grep !$_->is_located, shift->dependencies }
  sub dependencies { grep ref, @{+shift}{'base', 'delta'} }
  sub link_at
  {
    my ($self, $l) = @_;
    my $asm = phi::asm->locate($l);
    $asm->inline($$self{base})  if ref $$self{base};
    $asm->inline($$self{delta}) if ref $$self{delta};
    $asm;
  }

  sub location
  {
    my ($self, $asm) = @_;
    phi::location_of($$self{base}, $asm)
      + int $$self{scale} * phi::location_of($$self{delta}, $asm);
  }
}


package phi::asm_label
{
  # Shorthand: l"name" to refer to a label
  sub phi::l($) { phi::asm_label->new(shift) }

  use parent 'phi::asm_ptr';

  BEGIN { ++$INC{'phi/asm_label.pm'} }

  sub new
  {
    my ($class, $name) = @_;
    bless \$name, $class;
  }

  sub rewrite_left_right { shift }

  sub link_at      { phi::asm }
  sub dependencies { () }
  sub is_located   { 1 }
  sub location
  {
    my ($self, $asm) = @_;
    phi::location_of $asm->resolve($$self), $asm;
  }
}


# Magic references that will be rewritten (NB: bless into the class only once
# the class is defined; otherwise we may run into problems with operator
# overloading due to a perl magic-caching bug -- I forget which version fixed
# this).
#
# More specifically, "left" and "right" refer to the bounds of the current pack
# template expression. These are used to emit relative jumps, for example.
use constant left  => bless \(my $x = "left"),  'phi::asm_ptr';
use constant right => bless \(my $x = "right"), 'phi::asm_ptr';


=head3 Syscall macros
We end up issuing system calls to do basic setup and debugging, so it's worth
having these around and easy to access.
=cut

sub phi::asm::syscall6
{
  # Args are popped from the data stack in this layout:
  #
  #   arg6 arg5 ... arg1 syscallN syscall

  # It's important to save Ferris, so allocate some space on the return stack to
  # stash %rsi and %rdi -- both of which will be destroyed here.
  shift->_4883o305pc(-16)               # addq $-16, %rbp
       ->_4889o175pc(8)                 # movq %rdi, *(%rbp + 8)
       ->_4889o165pc(0)                 # movq %rsi, *%rbp

       ->_58                            # pop n -> %rax
       ->_5f5e5a                        # pop args 1, 2, 3
       ->_498fo302_498fo300_498fo301    # pop args 4, 5, 6
       ->_0f05                          # syscall insn
       ->_50                            # push result

       ->_488bo175pc(8)                 # movq *(%rbp + 8), %rdi
       ->_488bo165pc(0)                 # movq *%rbp,       %rsi
       ->_4883o305pc(16);               # addq $16, %rbp
}


=head3 Debugging code
Let's write some macros to make life much much easier. Basically, we want to
have some things we can drop into machine code to tell us what's going on inside
the image. We don't have libc, so int->string and such are functions we'll have
to write for ourselves if we want them.
=cut

sub phi::asm::exit_constant
{
  shift->_4831o300_b03c         # %rax = 0x3c (exit syscall)
       ->_48c7o307_pl(shift)    # %rdi = $code (exit code)
       ->_0f05;                 # syscall -- no return from here
}

sub phi::asm::debug_print
{
  my ($asm, $message, $fd) = @_;
  $fd //= 1;
  $asm->_50_52_56_57            # push %rax, %rdx, %rsi, %rdi
      ->_4831o300_b001          # %rax (n) = 1 (write syscall)
      ->_e8pl(length $message)  # call sizeof(message)
      ->lit($message)           # the message
      ->_5e                     # pop &message -> %rsi (buf)
      ->_bapl(length $message)  # mov length -> %rdx (len)
      ->_48c7o307pl($fd)        # %rdi (fd) = $fd
      ->_0f05                   # syscall
      ->_5f_5e_5a_58;           # pop %rdi, %rsi, %rdx, %rax
}


=head3 Perl C<use> helpers
The goal here is to specialize C<use constant> so we can write things like
C<use phi::code ...> and get custom handling. It's pretty simple: you can
request a new C<use> handler by registering a subroutine that takes all of the
arguments and returns a key/value binding list.

You need to call C<bind_use> from inside C<BEGIN>, of course.
=cut

sub bind_use
{
  no strict 'refs';
  my ($name, $handler) = @_;
  ++$INC{($name =~ s/::/\//gr) . ".pm"};
  *{"$name\::handler"} = $handler;
  *{"$name\::import"} = sub
  {
    # Shift off the class; presumably the handler is already aware of which
    # "use" specialization it's handling.
    shift;
    my %kvs  = &$handler(@_);
    my $into = \%{caller . "::"};
    $$into{$_} = $kvs{$_} for keys %kvs;
  };
}

sub const($)
{
  my $v = shift;
  sub() { $v };
}


=head2 Value types, pointers, and stacks
Let's talk about C for a second.

Idiomatic C can't be garbage collected accurately because we can't look at the
heap and know where the pointers are -- nor is there any guarantee that pointers
are even stored in any sane format. (XOR-linked lists, for example.) On the
bright side, C does provide some nice things like full-width unboxed integers
and floats.

C does have an understanding of pointer types, though; so if pointer/int casts
(and arbitrary memory access in general) were disallowed then it would be
possible to correctly GC it. C's stack layout is fully managed, so calculating
the root set is trivial.

FORTH is more challenging. The pointer/int casting rule isn't sufficient to add
GC because unlike in C, FORTH's stack types are generally unknown. That is, we
can't look at the data stack at a moment in time and understand which things on
it are pointers. If we wanted to be able to do this, we'd have to keep a bit of
separate information per entry indicating such.

Both languages are untyped in the sense that operators (mostly) reinterpret
their operands, but C is statically untyped while FORTH is dynamically untyped.

Polymorphic OOP, of course, doesn't work in an untyped world. We need some type
of runtime type information to be preserved per value in order to know which
variant of a method to resolve to. So our language becomes dynamically and
(probably) strongly typed. To the extent that coercion happens, it's driven by
the objects themselves -- objects are self-aware and self-managing.

If we take this principle to a logical extreme, there's no reason the garbage
collector needs to know anything about pointers or anything else. In fact,
there's no reason the language even needs a garbage collector. Objects with
direct memory access can be self-allocating, self-tracing, and self-relocating.

So ... how do we get to this wonderful paradise? The simplest strategy is to
kick things off with a concatenative, method-calling base with a few
instructions to rearrange the stack. Stack entries are value types, some of
which are pointers -- but the details of pointer dereferencing are delegated to
classes.


=head3 Base classes
vtables serve a structural role in phi's OOP implementation, but they are
themselves objects. They need to be in order to be garbage-collected (phi has no
permgen; if it did, you'd never be able to reclaim the bootup class/code objects
after replacing them).


=head4 Here pointers
There are cases where we'll want to refer to the middle of a structure for
linkage reasons. For example, a lot of references to native code should be
C<jmp>-able, so we want to point to the first byte of executable machine code,
but that machine code is owned and managed by a phi object whose base offset
comes a bit before. These cases are negotiated using C<here> pointers, each of
which is preceded by a two-byte struct offset. It would be like this in C:

  struct x *here = ...;
  struct x *base = (struct x*) ((char*) here - ((unsigned short*) here)[-1]);

In memory terms we have this:

                 here-pointer - heremarker = object root
                 |
  object root    |        here-pointer points here
  |              |        |
  V              V        V
  vtable ... heremarker | native code/whatever

All we need to do is keep track of whether we have a here-pointer, a regular
pointer, or something else.
=cut

sub phi::asm::here_marker
{
  my $asm = shift;
  $asm->pS(phi::right - $asm);
}


=head4 Metaclasses and vtables
Any object-oriented language with reflection faces the bottoming-out problem:
what is C<x.class.class>? phi's model is that C<class> is an instance of itself.

This would normally be a problem because the method-call machinery would be
self-referential, but phi introduces the class->vtable compilation step as a
layer of indirection to fix this. Rather than having the class _perform_ the
method calls, the class _compiles_ method calls (technically, protocols compile
method calls, but the principle is the same). So classes are source objects that
get compiled into vtables, which are the low-level things that implement
polymorphism.
=cut

BEGIN { bind_use 'phi::val', sub { $_[0] => const $_[1]->named($_[0]) } }

use phi::val vtable_vtable => asm;

sub phi::asm::vtable_header
{
  shift->pQ(vtable_vtable)
       ->pS((l("mend") - l("mstart")) / 8)
       ->here_marker
       ->lmstart;
}

BEGIN
{
  vtable_vtable->vtable_header;
  vtable_vtable->{args}[0] = [vtable_vtable->resolve("mstart")];

  bind_use 'phi::vtable', sub { $_[0] => const asm($_[0])->vtable_header };
}

sub phi::asm::object
{
  my ($self, $vtable) = @_;
  $self->pQ($vtable->resolve("mstart"));
}


=head3 Value classes
Every stack entry will end up being prefixed with a vtable pointer that
specifies how we should interpret that entry. This means our primitive
instructions are actually not how we will manipulate the stack at all; we'll end
up making method calls against stack things, which will push, pop, and rearrange
themselves for us.
=cut

use phi::vtable 'pointer_vtable';
use phi::vtable 'herepointer_vtable';
use phi::vtable 'int_vtable';
use phi::vtable 'real_vtable';


=head3 Instruction set
The simplest way to get this thing off the ground is to have a very small
handful of machine-code primitives that we then string together into functions.
These primitives don't need to be aware of OOP/memory management at all; they're
basically C-style int/pointer operations that operate in a concatenative way.

Why bother defining instructions above machine code? Because they're portable:
we want to minimize the processor-specific dependencies as much as we can. (None
of which precludes us from writing an optimizing compiler for any given backend
down the line.)

These instructions look almost exactly like FORTH primitives, and in fact I'm
going to use exactly the same register allocations that Jonesforth does:

  %rbp = return stack pointer
  %rsp = data stack pointer
  %rsi = instruction pointer
  %rdi = the interpreter object (not in Jonesforth; more below)

Our threading model is pretty different from Jonesforth. We don't execute
machine code directly; instead, we have a little bytecode interpreter that
includes some escapes for custom machine code sections. Specifically, here's our
instruction set (each is one byte):

  0x00 - 0x0f: invalid instructions (makes debugging easier)

  0x10 = lit8 (two-byte instruction)
  0x11 = lit16 (three-byte instruction)
  0x12 = lit32 (five-byte instruction)
  0x13 = lit64 (nine-byte instruction)

  0x18 - 0x1f: integer constants 0-7

  0x20 = call-native
  0x21 = call-interpreted
  0x22 = method-call-nth
  0x23 = if
  0x24 = iget
  0x25 = iset
  0x26 = dstack-get
  0x27 = dstack-set
  0x28 = rstack-get
  0x29 = rstack-set
  0x2a = rpush
  0x2b = rpop
  0x2c = ret
  0x2d = syscall6

  0x30 = swap
  0x31 = dup
  0x32 = drop
  0x33 = over
  0x34 = rot3<
  0x35 = nth (two-byte instruction)

  0x40 = <mem8
  0x41 = >mem8
  0x42 = <mem64
  0x43 = >mem64
  0x44 = memcpy

  0x50 = int+
  0x51 = int*
  0x52 = int<<
  0x53 = int>>
  0x54 = int>>>
  0x55 = int&
  0x56 = int|
  0x57 = int^
  0x58 = int<
  0x59 = int==
  0x5a = intunary~
  0x5b = intunary-

  0x80 - 0xbf: one-byte method call (0 - 31)
  0xc0 - 0xef: two-byte method call (32 - 12063)
  0xf0 - 0xff: three-byte method call (12064 - 524287)

TODO: instructions for managed languages? These all assume a flat memory model
with some amount of JIT capability. So we can target machine code, ASM.js, and
low-level bytecodes.

Using one byte per instruction means that our advancement primitive (NEXT in
Jonesforth) requires an additional instruction:

  # phi                                 # jonesforth
  xorq %rax, %rax                       lodsd
  lodsb                                 jmp *%eax
  jmp *(%rdi + 8*%rax)

C<%rdi> stores a here-pointer to the interpreter's bytecode dispatch table, so
there's no displacement. This reduces our overall code size.


=head4 Threading macros
These maintain registers and manage control flow. Every builtin instruction must
end with C<next> to advance the interpreter forwards.
=cut

sub phi::asm::next                      # 7 bytes
{
  shift->_4831o300                      # xor %rax, %rax
       ->_ac                            # lodsb
       ->_ffo044o307;                   # jmp *(%rdi + 8*%rax)
}

sub phi::asm::enter                     # 8 bytes
{
  shift->_4883o305pc(-8)                # addq $-8, %rbp
       ->_4889o165pc(0);                # movq %rsi, *%rbp
}

sub phi::asm::exit                      # 8 bytes
{
  shift->_488bo165pc(0)                 # movq *%rbp, %rsi
       ->_4883o305pc(8);                # addq $8, %rbp
}

sub phi::asm::mcall
{
  # Call method on an object _by value_!!!
  # %rsp = the object, %rcx = method number
  shift->_488bo004o044                  # movq *%rsp, %rax
       ->enter                          # save %rsi
       ->_488bo064o310;                 # movq *(%rax + 8*%rcx), %rsi
}


=head4 Code objects
The interpreter contains a dispatch table with 256 entries, one per bytecode
instruction. Each entry is an absolute pointer to the linkable address of a
machine code object, which is itself independently GC-able and contains some
metadata about the operation it represents.
=cut

use phi::vtable 'amd64_code_vtable';

BEGIN
{
  bind_use 'phi::insn', sub
  {
    my ($name, $asm) = @_;
    "insn_$name" => const
      asm("insn_$name")
        ->pQ(amd64_code_vtable->resolve("mstart"))
        ->pC(length $name)
        ->lit($name)
        ->pS(l("codeend") - l"codestart")
        ->here_marker
        ->lcodestart
        ->inline(TRACE_INSNS ? asm->debug_print("INSN\t$name\n") : asm)
        ->inline($asm)
        ->next
        ->lcodeend;
  };
}


=head4 Literal instructions
These are easy: we just use C<lods> to load the literal, then push it onto the
data stack.
=cut

use phi::insn lit8  => asm->  _ac_50;
use phi::insn lit16 => asm->_66ad_50;
use phi::insn lit32 => asm->  _ad_50;
use phi::insn lit64 => asm->_48ad_50;

use phi::insn litconst =>
  # %al stores the instruction, which is 0x18 higher than the literal int we
  # want to push.
  asm->_80o300pc(-0x18)                 # %al -= 0x18
     ->_50;                             # push %rax


=head4 Interpreter instructions

=cut

use phi::insn call_native =>
  # Call directly into the specified address. Return address is stack top, data
  # stack follows that; the function can do anything it wants as long as it
  # restores the values of %rbp, %rsi, and %rdi (and doesn't totally mangle
  # %rsp).
  asm->_58_48ffo320;

use phi::insn call_interpreted =>
  asm->enter                            # save continuation
     ->_5a;                             # pop into %rsi

use phi::insn method_call_nth =>
  asm->_59                              # pop method number into %rcx
     ->mcall;                           # invoke it

use phi::insn if =>
  # Concatenatively, usage is this: <cond> [then] [else] if, where cond is an
  # integer. So we conditionally move "then" into %rsi.
  asm->enter                            # save continuation
     ->_5a                              # pop else into %rsi
     ->_58                              # pop then into %rax
     ->_59                              # pop cond into %rcx
     ->_4885o311                        # test %rcx, %rcx
     ->_480f45o360;                     # cmovnz %rax, %rsi

use phi::insn iget =>
  # We don't want to return the contents of %rdi directly, even though %rdi does
  # point into the interpreter. The problem is that %rdi is a here-pointer, so
  # we need to subtract the two-byte unsigned quantity immediately before it.
  asm->_488bo307                        # mov %rdi, %rax
     ->_480fb7o117pc(-2)                # movzxw *(%rdi - 2), %rcx
     ->_482bo301                        # sub %rcx, %rax
     ->_50;                             # push %rax

use phi::insn iset =>
  # TODO: how do we ask the new interpreter for its %rdi pointer?
  asm->debug_print("unimplemented insn iset\n")
     ->exit_constant(1);

use phi::insn rget => asm->_55;
use phi::insn rset => asm->_5d;
use phi::insn dget => asm->_54;
use phi::insn dset => asm->_5c;

use phi::insn rpush =>
  asm->_58                              # pop %rax
     ->_4883o305pc(-8)                  # addq $-8, %rbp
     ->_4889o105pc(0);                  # movq %rax, *%rbp

use phi::insn rpop =>
  asm->_488bo105pc(0)                   # movq *%rbp, %rax
     ->_4883o305pc(8)                   # addq $8, %rbp
     ->_50;                             # push %rax

use phi::insn ret => asm->exit;

use phi::insn syscall6 => asm->syscall6;


=head4 Stack operations

=cut

use phi::insn swap  => asm->_5859_5051;
use phi::insn dup   => asm->_58_5050;
use phi::insn drop  => asm->_58;
use phi::insn over  => asm->_5859_505150;
use phi::insn rot3l => asm->_58595a_515250;
use phi::insn nth   =>
  asm->_ac                              # lodsb for index
     ->_ffo064o304;                     # push stack[%rax]


=head4 Memory instructions

=cut

use phi::insn mem8get  => asm->_58_8ao000_50;
use phi::insn mem8set  => asm->_5859_88o001;
use phi::insn mem64get => asm->_58_488bo000_50;
use phi::insn mem64set => asm->_5859_4889o001;

use phi::insn memcpy =>
  asm->_59                              # pop size -> %rcx
     ->_488bo337                        # mov %rdi, %rbx
     ->_5f                              # pop dest -> %rdi
     ->_488bo326                        # mov %rsi, %rdx
     ->_5e                              # pop source -> %rsi
     ->_f348a4                          # rep(%rcx) movsb
     ->_488bo373                        # restore %rdi
     ->_488bo362;                       # restore %rsi


=head4 Integer instructions

=cut

use phi::insn intplus  => asm->_5859_4803o301_50;
use phi::insn inttimes => asm->_5859_480fafo301_50;
use phi::insn intshl   => asm->_5958_48d3o340_50;
use phi::insn intsar   => asm->_5958_48d3o370_50;
use phi::insn intshr   => asm->_5958_48d3o350_50;
use phi::insn intand   => asm->_5859_4823o301_50;
use phi::insn intor    => asm->_5859_480bo301_50;
use phi::insn intxor   => asm->_5859_4833o301_50;

use phi::insn intlt =>
  # Arg ordering is such that [1 2 <] is false.
  asm->_5859                            # pop %rax (lhs), %rcx (rhs)
     ->_4831o322                        # xor %rdx, %rdx
     ->_483bo301                        # cmp %rcx to %rax
     ->_0f9co302                        # setl %rdx
     ->_52;                             # push %rdx

use phi::insn inteq =>
  asm->_5859                            # pop %rax, %rcx
     ->_4831o322                        # xor %rdx, %rdx
     ->_4885o301                        # test %rax, %rcx
     ->_0f94o302                        # sete %rdx
     ->_52;                             # push %rdx

use phi::insn intinv => asm->_48f7o024o344;
use phi::insn intneg => asm->_48f7o034o344;


=head4 Primitive method calls
The "method call" instructions always address the object pointed to by C<%rsp>,
which, in stack terms, is a value rather than a reference. Calling the nth
method involves using its vtable to fetch a pointer to a phi bytecode list, then
calling into that list. In other words, C<mcall(n)> is a much faster version of
this:

  dup <mem64                            # get vtable pointer
  lit(n) lit(8) int* int+               # get code pointer
  call-interpreted                      # invoke the method

NB: the method call instruction internals require their own instruction byte to
be present in C<%al>. This is a natural consequence of C<next>, which uses
C<lodsb>, but it's worth pointing out that this is a formal requirement.
=cut

use phi::insn mcall1 =>
  # One-byte method calls start at 0x80, so subtract 128
  asm->_04pc(-128)                      # %al -= 128
     ->_488bo310                        # mov %rax, %rcx
     ->mcall;

use phi::insn mcall2 =>
  # Two-byte method calls start at 0xf0, so subtract 240 and left-shift by eight
  asm->_04pc(16)                        # addb $16, %al
     ->_c1o340pc(8)                     # shld $8, %eax
     ->_ac                              # lodsb
     ->_488bo310                        # mov %rax, %rcx
     ->mcall;

use phi::insn mcall3 =>
  # Three-byte method calls start at 0xff, so no variation: just load two more
  # bytes
  asm->_66ad                            # lodsw
     ->_488bo310                        # mov %rax, %rcx
     ->mcall;


=head3 Interpreter object
The instruction set isn't OOP-aware, but the interpreter is an object. This is
important for a couple of reasons. First, the fact that the interpreter is just
a regular object means that it can be replaced; and second, as an object, it
ends up following the normal GC protocol so this replacement can happen
automatically when you stop referring to it.
=cut

use phi::vtable 'interpreter_vtable';

our @insns;
BEGIN
{
  @insns = map asm->lcodestart
                  ->debug_print(sprintf "illegal insn 0x%02x\n", $_)
                  ->exit_constant(1),
               0..255;

  @insns[0x10 .. 0x13] = (insn_lit8, insn_lit16, insn_lit32, insn_lit64);
  @insns[0x18 .. 0x1f] = (insn_litconst) x 8;

  @insns[0x20 .. 0x23] = (insn_call_native,
                          insn_call_interpreted,
                          insn_method_call_nth,
                          insn_if);

  @insns[0x24 .. 0x29] = (insn_iget, insn_iset,
                          insn_dget, insn_dset,
                          insn_rget, insn_rset);

  @insns[0x2c .. 0x2d] = (insn_ret, insn_syscall6);

  @insns[0x30 .. 0x35] = (insn_swap, insn_dup, insn_drop,
                          insn_over, insn_rot3l, insn_nth);

  @insns[0x40 .. 0x44] = (insn_mem8get,  insn_mem8set,
                          insn_mem64get, insn_mem64set,
                          insn_memcpy);

  @insns[0x50 .. 0x53] = (insn_intplus, insn_inttimes, insn_intshl, insn_intsar);
  @insns[0x54 .. 0x57] = (insn_intshr,  insn_intand,   insn_intor,  insn_intxor);
  @insns[0x58 .. 0x5b] = (insn_intlt,   insn_inteq,    insn_intinv, insn_intneg);

  @insns[0x80 .. 0xef] = (insn_mcall1) x (0xf0 - 0x80);
  @insns[0xf0 .. 0xfe] = (insn_mcall2) x (0xff - 0xf0);
  $insns[0xff]         = insn_mcall3;
}


use phi::val 'interpreter_object' => asm
  ->pQ(interpreter_vtable->resolve("mstart"))
  ->here_marker
  ->litable
  ->pQ256(map $_->resolve("codestart"), @insns);


=head3 Backend variants
We want to be able to run within different languages, the set of which spans
things like memory models, OOP/functional, and other paradigm differences. Some
cases like ASM.js involve bridging that gap within the same runtime. Because all
of this involves hard limits (we don't want to emulate a flat memory model if
the runtime provides GC for us), phi provides an operation that tells you about
the features available on the current runtime. Then you'll know which
instructions are enabled.

=head4 C<gc>
This is the biggest question mark for a runtime: how is memory managed? There
are a few options:

1. C<flat>: no GC; you have direct memory access (e.g. C, C++, machine code)
2. C<named>: no references/pointers (e.g. Perl4, POSIX sh, sed)
3. C<refcount>: cycles need to be broken, finalizers happen instantly (Perl5)
4. C<sync_tracing>: synchronous (pausing) mark/sweep (OCaml, Ruby?)
5. C<async_tracing>: concurrent mark/sweep (Java)

TODO: finalizer support?

=head4 C<int_size>
Basically, how big an int can we work with before overflowing a register? Sadly,
the number of bits is not always an even power of two; V8, OCaml, and Lisp each
use some form of bit tagging, reducing the effective integer precision to
slightly fewer than the native number of bits. On a 64-bit machine, this usually
means we get anywhere from 52 to 63 bits to work with (52 comes up if the
runtime pushes ints into NaN float values).

C<int_size> uses eight bits to encode the number of bits available in integers.

=head4 C<jit>
This setting can take on a few different values:

1. C<free>: there is no JIT overhead at all, e.g. machine code
2. C<fast>: you can quickly compile code at runtime, e.g. C<eval>
3. C<slow>: you can compile code via linkage, e.g. with the JVM; expect permgen
4. C<none>: you can't JIT anything; you'd have to restart the process
=cut

# TODO: implement variant support, whatever that ends up being


=head2 Classes and protocols
In a world with only classes, we'd need to allocate a separate vtable index for
every single method, which would take up a lot of space:

  # the world without protocols: every class contains four vtable entries
  class A {
    method foo;     # vtable index 0
    method bar;     # vtable index 1
  }
  class B {
    method foo;     # vtable index 0
    _               # vtable index 1 is blank to avoid A::bar conflict
    method bif;     # vtable index 2
    method baz;     # vtable index 3
  }

This is equivalent to every class belonging to a single protocol that contains
the union of everyone's methods.

We can fix this by specifying which classes are eligible for which virtual
method calls, in this case by adding them to a protocol object:

  protocol has_foo {
    method foo;     # same vtable index within all member classes
  }
  class A : has_foo {
    method foo;     # vtable index 0
    method bar;     # vtable index 1
  }
  class B : has_foo {
    method foo;     # vtable index 0
    method bif;     # vtable index 1 (no collision with A::bar)
    method baz;     # vtable index 2
  }

This is basically how method resolution works in statically-typed languages like
Java or C++; phi also uses static typing when it comes to classes/methods, it
just has more support for runtime code generation.

Every virtual method invocation, then, addresses a protocol rather than a class.
Any class-focused method invocations are static function calls and are likely to
be inlined during compilation.

NB: we can't modify vtables once they're allocated, so compiled classes,
vtables, and dynamic method calls are all immutable once you start using them.
It's theoretically possible to enumerate heap objects and rewrite their vtables
if all you're doing is adding new methods to things, but that's a library thing
instead of something built into the object system.
=cut

# TODO: implement stuff


=head2 Build the image
This is pretty simple: we just write the entire heap contents into a file and
call it a day. This works because the heap begins with ELF header allocations
that locate it properly in memory.
=cut

use constant elf_startaddr         => 0x400000;
use constant elf_return_stack_size => 0x100000;


# DEBUG
interpreter_vtable
  ->pQ(asm("interp.print_char")         # method 0 = debug_print_char
    ->pC(0x32)                          # drop receiver
    ->pCQCC(0x13,                       # lit64 to push native
            asm("interp.print_char_native")
              ->_59585150               # (ret, char) -> (char, ret)
              ->_488bo304               # mov %rsp, %rax
              ->_515151                 # args 4, 5, 6
              ->_6apc(1)                # count = 1
              ->_50                     # buf = &char on stack
              ->_6apc(1)                # fd = 1
              ->_6apc(1)                # n = 1
              ->syscall6                # now we have (n, char, ret) on stack
              ->_5858                   # now we have (ret)
              ->_c3,
            0x20,                       # call_native
            0x2c))                      # ret

  ->pQ(asm("interp.exit")               # method 1 = debug_exit
    ->pC(0x32)                          # drop receiver
    ->pCQC(0x13,                        # lit64 to push native
           asm("interp.exit_native")->exit_constant(42),
           0x20));                      # call_native (never returns)


use phi::val initial_list => asm
  ->pC5(0x10, ord"f",  0x24, 0x42, 0x80)
  ->pC5(0x10, ord"o",  0x24, 0x42, 0x80)
  ->pC5(0x10, ord"o",  0x24, 0x42, 0x80)
  ->pC5(0x10, ord"\n", 0x24, 0x42, 0x80)
  ->pC3(0x24, 0x42, 0x81);

use phi::val entry_point => asm
  # Allocate initial return stack. We need to provide two stack entries for
  # %rbp, though, since syscall6 tries to stash %rsi and %rdi for us. Luckily we
  # have an entire ELF header we can destroy. Let's nuke the first two entries.
  ->_48c7o305pl(elf_startaddr + 16)

  ->_6apc(0)            # push offset = 0
  ->_6apc(-1)           # push fd = -1
  ->_6apc(0x22)         # push flags = MAP_ANONYMOUS | MAP_PRIVATE
  ->_6apc(7)            # push prot = R|W|X
  ->_68pl(elf_return_stack_size)
  ->_6apc(0)            # push addr = 0
  ->_6apc(9)            # push n = __NR_MMAP
  ->syscall6            # now beginning of region is on the data stack
  ->_5d                 # pop region -> %rbp

  ->_4881o305pl(elf_return_stack_size)                  # initialize %rbp
  ->_48bfpQ(interpreter_object->resolve("itable"))      # initialize %rdi
  ->_48bepQ(initial_list)                               # initialize %rsi
  ->next;                                               # start interpreter


=head3 vtable finalization
We need to put end labels onto each of our vtables. TODO: migrate this into a
more managed process.
=cut

vtable_vtable->lmend;
amd64_code_vtable->lmend;
interpreter_vtable->lmend;


=head3 ELF header
These behave like heap allocations because of page alignment. Basically, let's
say our virtual address space starts at 0x400000; because the ELF file is
memory-mapped rather than copied, we have the constraint that we can "move" the
file's contents only by increments of 4096 bytes -- whole pages. We can't assign
an arbitrary offset, e.g. to skip the ELF header.

This isn't much of a problem really. As far as phi is concerned, our initial
heap is maybe 120 bytes smaller than it would normally be because it's got some
mystery data (the ELF headers) prepended; then that will get garbage collected
because nothing refers into it. So the net impact of our ELF headers ends up
being zero, exactly what we want.
=cut

use phi::val elf_hdr => asm
  ->locate(elf_startaddr)
  ->pC16_SSL(
    0x7f, ord 'E', ord 'L', ord 'F',
    2, 1, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,

    2,                                  # e_type    = ET_EXEC
    62,                                 # e_machine = EM_X86_64
    1)                                  # e_version = EV_CURRENT
  ->pQ(entry_point)
  ->pQQ_LSS_SSSS(
    64,                                 # e_phoff
    0,                                  # e_shoff
    0,                                  # e_flags

    64,                                 # e_ehsize
    56,                                 # e_phentsize
    1,                                  # e_phnum

    0,                                  # e_shentsize
    0,                                  # e_shnum
    0)                                  # e_shstrndx
  ->pLLQQQQQQ(
    1,                                  # p_type = PT_LOAD
    7,                                  # p_flags = R|W|X (important)
    0,                                  # p_offset (must be page-aligned)
    elf_startaddr,                      # p_vaddr
    0,                                  # p_paddr
    l("iend") - l"istart",              # p_filesz
    l("iend") - l"istart",              # p_memsz
    0x1000);                            # p_align


=head3 Heap construction
Allocate everything into the heap, dependencies last. C<elf_hdr> must be the
first object we allocate in order to generate a valid executable.
=cut

elf_hdr->locate(elf_startaddr)
       ->listart
       ->inline(entry_point)
       ->liend;

# Debugging: emit all object locations into a listing file
open my $fh, '> phi.symbols';
printf $fh "%d\t%d\t%06x\t%s\n", $phi::asm::all_located{$_}->location,
                                 $phi::asm::all_located{$_}->size,
                                 $phi::asm::all_located{$_}->location,
                                 $_
  for sort { $phi::asm::all_located{$a}->location
                <=> $phi::asm::all_located{$b}->location
             || $a cmp $b }
           keys %phi::asm::all_located;
close $fh;

print elf_hdr->linked unless caller;

1;
