#!/usr/bin/env perl

=head1 License
    phi programming language
    Copyright (C) 2018  Spencer Tipping

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.


=head1 phi boot image generator
This script emits a Linux/AMD64 machine code image. We aren't linked to any
libraries (including libc), so everything bottoms out in terms of system calls
and we aren't at all portable to other POSIX systems. This is an OK place to
start the world; later on we can specify how to build a C+JIT system that
interfaces to system functions using the standard C calling convention. The
image can then port itself to this backend.

Not all backends are low-level; we just start there because it's conveniently
minimalistic. phi can also recompile itself to languages like Javascript,
Python, Ruby, Perl, OCaml, Java, etc, each of which provides some form of GC
and/or OOP. phi is set up to delegate to hosting facilities when they're
available. (Optimizing effectively for each backend is another story that I'll
address within the phi codegen libraries.)
=cut

package phi;

use v5.14;          # required for pack() endian modifiers, // operator
use strict;
use warnings;
no warnings 'void';

use Carp;

BEGIN
{
  $Carp::Verbose = 1;
  $SIG{__DIE__} = sub { Carp::confess @_ };

  push @INC, $0 eq "-" ? "$ENV{PWD}/boot"
                       : $0 =~ s/\/[^\/]+$/\/boot/r;
}


=head2 General build/debug settings
We want to be able to inspect various aspects of phi's behavior quickly, so I've
built in a bunch of conditional build settings that compile debug tracers into
the image if we need them.
=cut

use constant DEBUG_TRACE_INSNS  => 0;
use constant DEBUG_EMIT_SYMBOLS => 1;


=head2 Assembler/perl metaprogramming
Non-phi-specific stuff that we can use to write and link machine code.
C<phi::use> is a mechanism to specialize perl's C<use> construct to define
custom types of things with metaprogramming; it saves us from having to wrap
stuff into C<BEGIN{}> blocks, but otherwise isn't especially interesting. (New
C<use> forms are defined by writing C<use phi::use ...>.)
=cut

use phi::use;
use phi::asm;
use phi::asm_macros;


=head2 phi boot layer
Enough stuff to get phi off the ground so it can write its own
objects/functions/etc. This doesn't take much; it's basically a small bytecode
interpreter, a few structs, and some parser classes.
=cut

use phi::obj;
use phi::interp;


$_->assemble_full for @{+all_vtables};


1;
