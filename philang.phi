Obviously, eager partial-evaluation is asking for trouble: first, what happens
when you have an unknowable decision over a recursive function? Eager evaluation
would demand that we fully force the recursion, which might never end. And this
brings us to the final part of C<eval>, the speculation limiter.

=head3 C<eval>, speculative execution, and entropy
As a human you have an intuitive sense about code that you're analyzing: you
might feel optimistic about something straightforward like a list-map function,
but you would quickly give up on C<sha256>. One reason you might feel this way
is that C<map> is highly structured: any input entropy is confined to a small
region of output; whereas C<sha256> is specifically designed to distribute
entropy throughout its output value and internal state. Put differently, C<map>
is more easily reverse-engineered than C<sha256>.

phi can simulate this intuition by limiting the amount of entropy it's willing
to speculate about. For example, maybe we have a limit of four bits of total
entropy; then we would speculatively evaluate four iterations of C<map>:

  map f xs = match xs with              # two outcomes = one bit of entropy
    | x::xs' -> (f x) :: map f xs'
    | []     -> []
    | _      -> crash                   # this branch is implied and eliminated

This is a bit of a lie, of course; there are some lists for which we would
speculatively evaluate many more iterations -- and that has to do with
entanglement.

=head3 Entanglement and collapse
Let's take a trivial example:

  x == nil ? (x == nil ? 1 : 2)
           : (x == nil ? 3 : 4)

If we assume C<x> is an unknown (either cons or nil) and we apply the naive
entropy formula to this expression, we'll get two bits -- but the second is
obviously fictitious because it's identical to the first. Both bits are
predicated on the same underlying unknown quantity, which makes them entangled.

One way to model this is to propagate assertions:

  x == nil ? [assume   x == nil ] (x == nil ? 1 : 2) -> 1
           : [assume !(x == nil)] (x == nil ? 3 : 4) -> 4

Not everything is quite so trivial, for instance:

  x xor y ? (x ? (y ? 1 : 2) : (y ? 3 : 4))
          : (x ? (y ? 5 : 6) : (y ? 7 : 8))

Although C<x xor y> doesn't tell us either value, we can still eliminate any
branch for which C<x xor y> differs from our asserted value. This is a
convenient model because it allows us to use arbitrarily complex expressions as
assertions without directly reverse-engineering them.
