#!/usr/bin/env perl
package phi;

use strict;
use warnings;

no warnings 'precedence';

use Carp;
use Data::Dumper;

$Data::Dumper::Indent = 0;

use phi::compiler;
use editor ();

BEGIN
{
  $SIG{__DIE__} = sub { system 'stty sane'; print Carp::longmess(@_);
                        system 'reset' };
}
# Editor setup
use constant e => phi::editor::buffer->new(<<'EOF');
# Let's define a struct
# x = (1, 2)
# point = (1, 2)
EOF

use constant c => phi::editor::cursor->new(e);


use Time::HiRes qw/time/;
use JSON;
use constant je => JSON->new->allow_nonref(1)->convert_blessed(1);

use constant t_int     => phi::compiler::type_int->new;
use constant t_string  => phi::compiler::type_string->new;
use constant t_unknown => phi::compiler::type_unknown->new;
use constant t_any     => phi::compiler::type_any->new;

use constant root_scope => phi::compiler::scope_root->new(undef)
  ->link(t_int->literal_parser)
  ->link(t_string->literal_parser)
  ->link(t_unknown->literal_parser)
  ->link(phi::compiler::type_tuple->literal_parser)
  ->bind(int     => t_int,
         string  => t_string,
         unknown => t_unknown,
         any     => t_any,
         fn_type => phi::compiler::abstract_hosted_fn->new(
                      'fn_type',
                      sub {
                        my ($arg, $return) = @{shift->val->get};
                        phi::compiler::type_fn->new($arg, $return);
                      },
                      phi::compiler::type_tuple->new(t_any, t_any),
                      phi::compiler::type_fn->new(t_any, t_any)),

         fn      => phi::compiler::syntactic_fn->new);

use List::Util qw/min/;

system 'stty raw; stty -echo isig -ignbrk -brkint -ixon -ixoff';

my $ibuf = '';
while (read STDIN, $ibuf, 1, length $ibuf)
{
  $ibuf = substr $ibuf, 1 if $ibuf =~ /^\033/ && length $ibuf > 4;

  my $orig_pos = c->pos;

  c->col(0)  while $ibuf =~ s/^\033\[7~//;
  c->col(-1) while $ibuf =~ s/^\033\[8~//;
  c->move($1 eq 'A' ? -1 : $1 eq 'B' ? 1 : 0,
          $1 eq 'D' ? -1 : $1 eq 'C' ? 1 : 0)
    while $ibuf =~ s/^\033\[([ABCD])//;

  c->backspace(c->col || 1) while $ibuf =~ s/^\x15//;
  c->backspace              while $ibuf =~ s/^\x7f//;
  c->delete                 while $ibuf =~ s/^\033\[3~//;

  c->insert("  ") while $ibuf =~ s/^\t//;
  c->insert("\n") while $ibuf =~ s/^\r//;
  c->insert($1)   while $ibuf =~ s/^([^\033\x7f\x15]+)//;

  my $pos         = c->pos;
  my ($row, $col) = c->rowcol;

  print "\033[H\033[J";

  for my $l (0..e->lines + 2)
  {
    my $r = $l + 1;
    print "\033[$r;1H\033[K\033[0;0m" . (e->line($l) // '');
  }

  my $last_r  = e->lines + 1;
  my $error   = undef;
  my $plength = 0;
  my $explain =
    eval
    {
      local $SIG{__DIE__} = sub {
        print STDERR Carp::longmess(@_) =~ s/\n/\r\n/gr;
      };
      my ($ok, $l, $x) = root_scope->parse(e, 0);

      $plength = $l;

      #Dumper("ok = $ok", @xs) =~ s/\n/\r\n/gr;
      $x->can('val')
        #? Dumper("ok = $ok", $x->val) =~ s/\n/\r\n/gr
        ? $x->val
        : Dumper("ok = $ok", $x) =~ s/\n/\r\n/gr;
    } // $@;

  {
    no warnings 'uninitialized';
    print "\033[$last_r;1H\033[K\033[0;37m$plength -> $explain";
    ++$last_r;
    #print "\033[$last_r;1H\033[K\033[0;37m" . Dumper($error);
  }

  my ($r, $c) = c->rowcol;
  $r++;
  $c++;
  print "\033[$r;${c}H";
}

system 'reset';
