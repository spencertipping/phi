#!/usr/bin/env perl
use strict;
use warnings;

use Carp;

$SIG{__DIE__} = sub
{
  system 'reset';
  Carp::confess(@_);
};

BEGIN
{
  do 'parser.pm';
  do 'parsestr.pm';
  do 'editor.pm';
}


package phi;

use JSON;
use constant je => JSON->new->allow_nonref(1)->allow_blessed(1);

use List::Util qw/min/;

use Data::Dumper;

use constant e => phi::editor::buffer->new('[1]');
use constant c => phi::editor::cursor->new(e);

use constant expr => phi::parser::forward->new;

use constant number =>
  phi::parser::map->new(
    phi::parser::strclass->many_of('0'..'9'),
    sub { "n[$_]" });

use constant operator =>
  phi::parser::map->new(
    phi::parser::strclass->many_of('+-*/&^%!~:'),
    sub { "op[$_]" });

use constant list =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('['),
      expr,
      phi::parser::seq_repeat->new(
        phi::parser::map->new(
          phi::parser::seq_fixed->new(
            phi::parser::strconst->new(','),
            expr),
          sub { $$_[1]->val })),
      phi::parser::strconst->new(']')),
    sub { my ($first, $rest) = @$_[1, 2];
          [$first->val, map $_->val, @{$rest->val}] });

use constant atom => phi::parser::alt_fixed->new(
  number,
  list,
  phi::parser::strconst->new('foo'),
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('('),
      expr,
      phi::parser::strconst->new(')')),
    sub { $$_[1]->val }));

use constant binop =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      atom,
      phi::parser::seq_repeat->new(
        phi::parser::seq_fixed->new(operator, atom),
        1)),
    sub { my ($first, $rest) = @$_;
          [$first->val,
           map $_->val ? map $_->val, @{$_->val} : (),
               @{$rest->val}] });

expr->set(phi::parser::alt_fixed->new(
  binop,
  atom));


system 'stty raw; stty isig -ignbrk -brkint';

my $parsed = expr->on(e);
my $ibuf = '';
while (read STDIN, $ibuf, 1, length $ibuf)
{
  my $orig_pos = c->pos;
  my $ascii = ord $ibuf;
  c->backspace(c->col || 1) while $ibuf =~ s/^\x15//;
  c->backspace              while $ibuf =~ s/^\x7f//;
  c->delete                 while $ibuf =~ s/^\033\[3~//;
  c->col(0)                 while $ibuf =~ s/^\033\[7~//;
  c->col(-1)                while $ibuf =~ s/^\033\[8~//;

  c->move($1 eq 'A' ? -1 : $1 eq 'B' ? 1 : 0,
          $1 eq 'D' ? -1 : $1 eq 'C' ? 1 : 0)
    while $ibuf =~ s/^\033\[([ABCD])//;

  c->insert("\n") while $ibuf =~ s/^\r//;
  c->insert($1)   while $ibuf =~ s/^([^\033\x7f\x15]+)//;

  my $pos = c->pos;
  my ($row, $col) = c->rowcol;

  print "\033[1;1H\033[J";
  my $output = $parsed->parse(min $orig_pos, $pos);
  my $repr   = $output->is_ok ? Dumper($output->val)
                              : "failed at " . ref $output->error;
  $repr =~ s/\n/\n\r/g;
  for my $l (0 .. e->lines)
  {
    my $r = $l + 2;
    print "\033[$r;1H" . ($l < e->lines ? e->line($l) : $repr);
  }

  my ($r, $c) = c->rowcol;
  $r += 2;
  $c++;
  print "\033[$r;${c}H";
}

system 'reset';
