#!/usr/bin/env perl
use strict;
use warnings;

use Carp;

$SIG{__DIE__} = sub
{
  system 'reset';
  Carp::confess(@_);
};

BEGIN
{
  do 'parser.pm';
  do 'parsestr.pm';
  do 'parseapi.pm';
  do 'editor.pm';
}


package phi;

use JSON;
use constant je => JSON->new->allow_nonref(1)->convert_blessed(1);

use List::Util qw/min/;

use Data::Dumper;

use constant e => phi::editor::buffer->new(<<'EOF');
# let's assign some variables
x = 10;
y = 20;

# and let's do some operations
sum = x + y;
(sum * 10) > 5;
EOF

use constant c => phi::editor::cursor->new(e);

use constant expr => phi::parser::forward->new;

use constant ws =>
  phi::parser::alt_fixed->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('#'),
      phi::parser::strclass->many_except("\n")),
    phi::parser::strclass->many_of(" \n\r\t"));

use constant number =>
  phi::parser::map->new(
    phi::parser::strclass->many_of('0'..'9'),
    sub { 0 + $_[0] });

use constant word =>
  phi::parser::map->new(
    phi::parser::strclass->many_of('a'..'z', 'A'..'Z', '_'),
    sub { "word[$_[0]]" });

use constant operator => phi::parser::strclass->many_of('+-*/&^%!~:.=<>|');

use constant string =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('"'),
      phi::parser::seq_repeat->new(
        phi::parser::alt_fixed->new(
          phi::parser::strclass->many_except("\\\""),
          phi::parser::seq_fixed->new(
            phi::parser::strconst->new("\\"),
            phi::parser::strclass->one_except('')))),
      phi::parser::strconst->new('"')),
    sub {
      my (undef, $stuff) = @{$_[0]};
      return undef unless defined $stuff;
      my $sv = $stuff->val;
      join'', map $_->val, @$sv;
    });

use constant list =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('['),
      expr,
      phi::parser::seq_repeat->new(
        phi::parser::map->new(
          phi::parser::seq_fixed->new(
            phi::parser::strconst->new(','),
            expr),
          sub { defined $_[0]->[1] ? $_[0]->[1]->val : undef })),
      phi::parser::strconst->new(']')),
    sub { my ($first, $rest) = @{$_[0]}[1, 2];
          my $fv = defined($first) ? $first->val : undef;
          my $rv = defined($rest)  ? $rest->val  : [];
          [$fv, map $_->val, @$rv] });

use constant parens =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('('),
      expr,
      phi::parser::strconst->new(')')),
    sub { my $v = shift->[1];
          defined $v ? $v->val : undef });

use constant atom_val =>
  phi::parser::alt_fixed->new(
    parens,
    number,
    list,
    string,
    word);

use constant atom =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::seq_repeat->new(ws),
      atom_val,
      phi::parser::seq_repeat->new(ws)),
    sub { defined ${$_[0]}[1] ? ${$_[0]}[1]->val : undef });

use constant binop =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      atom,
      phi::parser::seq_repeat->new(
        phi::parser::seq_fixed->new(operator, atom),
        1)),
    sub { my ($first, $rest) = @{$_[0]};
          my $rv = $rest  ? $rest->val  : [];
          [$first, @$rv] });

expr->set(phi::parser::alt_fixed->new(
  binop,
  atom));

use constant program =>
  phi::parser::map->new(
    phi::parser::seq_repeat->new(
      phi::parser::seq_fixed->new(
        expr,
        phi::parser::strconst->new(';'))),
    sub { [map $_->val->[0], @{$_[0]}] });


system 'stty raw; stty -echo isig -ignbrk -brkint';

#my $parsed = program->on(e);
my $ibuf = '';
while (read STDIN, $ibuf, 1, length $ibuf)
{
  my $orig_pos = c->pos;
  my $ascii = ord $ibuf;
  c->backspace(c->col || 1) while $ibuf =~ s/^\x15//;
  c->backspace              while $ibuf =~ s/^\x7f//;
  c->delete                 while $ibuf =~ s/^\033\[3~//;
  c->col(0)                 while $ibuf =~ s/^\033\[7~//;
  c->col(-1)                while $ibuf =~ s/^\033\[8~//;

  c->move($1 eq 'A' ? -1 : $1 eq 'B' ? 1 : 0,
          $1 eq 'D' ? -1 : $1 eq 'C' ? 1 : 0)
    while $ibuf =~ s/^\033\[([ABCD])//;

  c->insert("\n") while $ibuf =~ s/^\r//;
  c->insert($1)   while $ibuf =~ s/^([^\033\x7f\x15]+)//;

  my $pos = c->pos;
  my ($row, $col) = c->rowcol;

#  my $output = $parsed->parse(min($orig_pos, $pos), $pos + 1);
#  my $repr   = defined $output ? $output->explain : 'undef';

#  $repr =~ s/\n/\n\r/g;
#  $repr = "\033[J\033[0;32m$repr\033[0;0m";
  for my $l (0 .. e->lines)
  {
    my $r = $l + 1;
#    print "\033[$r;1H\033[K" . ($l < e->lines ? e->line($l) : $repr);
    print "\033[$r;1H\033[K" . ($l < e->lines ? e->line($l) : '');
  }

  my ($r, $c) = c->rowcol;
  $r++;
  $c++;
  print "\033[$r;${c}H";
}

system 'reset';
