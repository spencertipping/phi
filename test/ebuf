#!/usr/bin/env perl
use strict;
use warnings;

use Carp;

$SIG{__DIE__} = sub
{
  system 'reset';
  Carp::confess(@_);
};

BEGIN
{
  do 'parser.pm';
  do 'parsestr.pm';
  do 'editor.pm';
}


package phi;

use JSON;
use constant je => JSON->new->allow_nonref(1)->allow_blessed(1);

use List::Util qw/min/;

use Data::Dumper;

use constant e => phi::editor::buffer->new('');
use constant c => phi::editor::cursor->new(e);

use constant expr => phi::parser::forward->new;

use constant ws => phi::parser::strclass->many_of(" \n\r\t");

use constant number =>
  phi::parser::map->new(
    phi::parser::strclass->many_of('0'..'9'),
    sub { "n[$_[0]]" });

use constant word =>
  phi::parser::map->new(
    phi::parser::strclass->many_of('a'..'z', 'A'..'Z'),
    sub { "word[$_[0]]" });

use constant operator =>
  phi::parser::map->new(
    phi::parser::strclass->many_of('+-*/&^%!~:'),
    sub { "op[$_[0]]" });

use constant list =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('['),
      expr,
      phi::parser::seq_repeat->new(
        phi::parser::map->new(
          phi::parser::seq_fixed->new(
            phi::parser::strconst->new(','),
            expr),
          sub { defined $_[0]->[1] ? $_[0]->[1]->val : undef })),
      phi::parser::strconst->new(']')),
    sub { my ($first, $rest) = @{$_[0]}[1, 2];
          [$first->val,
           defined($rest) ? map defined ? $_->val : undef,
                                @{$rest->val}
                          : ()] });

use constant parens =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::strconst->new('('),
      expr,
      phi::parser::strconst->new(')')),
    sub { ${$_[0]}[1]->val });

use constant atom_val =>
  phi::parser::alt_fixed->new(
    number,
    list,
    word);

use constant atom =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      phi::parser::seq_repeat->new(ws),
      atom_val,
      phi::parser::seq_repeat->new(ws)),
    sub { defined ${$_[0]}[1] ? ${$_[0]}[1]->val : undef });

use constant binop =>
  phi::parser::map->new(
    phi::parser::seq_fixed->new(
      atom,
      phi::parser::seq_repeat->new(
        phi::parser::seq_fixed->new(operator, atom),
        1)),
    sub { my ($first, $rest) = @{$_[0]};
          [$first->val,
           defined $rest ? map @{$_->val}, @{$rest->val}
                         : ()] });

expr->set(phi::parser::alt_fixed->new(
  binop,
  atom));


system 'stty raw; stty -echo isig -ignbrk -brkint';

my $parsed = expr->on(e);
my $ibuf = '';
while (read STDIN, $ibuf, 1, length $ibuf)
{
  my $orig_pos = c->pos;
  my $ascii = ord $ibuf;
  c->backspace(c->col || 1) while $ibuf =~ s/^\x15//;
  c->backspace              while $ibuf =~ s/^\x7f//;
  c->delete                 while $ibuf =~ s/^\033\[3~//;
  c->col(0)                 while $ibuf =~ s/^\033\[7~//;
  c->col(-1)                while $ibuf =~ s/^\033\[8~//;

  c->move($1 eq 'A' ? -1 : $1 eq 'B' ? 1 : 0,
          $1 eq 'D' ? -1 : $1 eq 'C' ? 1 : 0)
    while $ibuf =~ s/^\033\[([ABCD])//;

  c->insert("\n") while $ibuf =~ s/^\r//;
  c->insert($1)   while $ibuf =~ s/^([^\033\x7f\x15]+)//;

  my $pos = c->pos;
  my ($row, $col) = c->rowcol;

  my $output = $parsed->parse(min($orig_pos, $pos), $pos);
  my $repr   = defined $output
             ? $output->is_ok ? Dumper($output->val)
                              : "failed at " . ref $output->error
             : 'undef';

  $repr =~ s/\n/\n\r/g;
  $repr = "\033[J$repr";
  for my $l (0 .. e->lines)
  {
    my $r = $l + 1;
    print "\033[$r;1H\033[K" . ($l < e->lines ? e->line($l) : $repr);
  }

  my ($r, $c) = c->rowcol;
  $r += 1;
  $c++;
  print "\033[$r;${c}H";
}

system 'reset';
