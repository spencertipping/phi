#!/usr/bin/env perl
use strict;
use warnings;

no warnings 'precedence';

use Carp;

BEGIN
{
  $SIG{__DIE__} = sub { system 'stty sane'; Carp::confess(@_); system 'reset' };
  require 'parser.pm';
  require 'parsestr.pm';
  require 'parseapi.pm';
  require 'editor.pm';
}


package phi;

sub str($) { phi::parser::strconst->new(shift) }

sub oc { phi::parser::strclass->one_of(@_) }
sub mc { phi::parser::strclass->many_of(@_) }
sub oe { phi::parser::strclass->one_except(@_) }
sub me { phi::parser::strclass->many_except(@_) }

# Grammar definitions
my $expr_ref    = phi::parser::forward->new;
my $program_ref = phi::parser::forward->new;

my $expr    = $expr_ref    <'phi::syntax::expr';
my $program = $program_ref <'phi::syntax::program';

my $ws     = str('#!') + me("\n") <'phi::syntax::shebang'
           | str('#') + me("\n")  <'phi::syntax::line_comment'
           | str('#')             <'phi::syntax::delimiter'
           | mc(" \n\r\t")        <'phi::syntax::whitespace';

my $number = mc('0'..'9') <'phi::syntax::number';

my $word   = mc('a'..'z',
                'A'..'Z',
                '0'..'9', '_') <'phi::syntax::word';

my $path   = mc('-/_.+', 'a'..'z', 'A'..'Z', 0..9) <'phi::syntax::path';
my $op     = (mc('+-*/|&^%!~:.=<>?') | str("")) <'phi::syntax::op';

my $string = (str('"') + (me("\\\"") | str("\\") + oe('')) + str('"'))
             <'phi::syntax::string';

my $list   = ((str"[" <'phi::syntax::delimiter')
              + ($expr + (str"," <'phi::syntax::delimiter')*0)*0
              + (str"]" <'phi::syntax::delimiter'))
             <'phi::syntax::list';

my $parens = (str"(" <'phi::syntax::delimiter')
             + $expr
             + (str")" <'phi::syntax::delimiter') <'phi::syntax::parens';

my $block  = (str"{" <'phi::syntax::delimiter')
             + $program
             + (str"}" <'phi::syntax::delimiter') <'phi::syntax::block';

my $atom  = $ws * 0
            + ($parens | $block | $number | $list | $string | $word | $path)
            + $ws * 0
            <'phi::syntax::atom';
my $binop = ($atom + ($op + $atom | $atom) * 1) <'phi::syntax::binop';

$expr_ref->set($binop | $atom);
$program_ref->set(($expr + (str(';') <'phi::syntax::delimiter')*0) * 0 + $ws * 0);


# Parser sub-language
my $parse_expr_ref = phi::parser::forward->new;
my $parse_expr     = $parse_expr_ref <'phi::syntax::parse_expr';
my $parse_parens   = (str('(') <'phi::syntax::delimiter')
                   + $parse_expr
                   + (str(')') <'phi::syntax::delimiter') <'phi::syntax::parens';

my $parse_class    = str('[') + me("\\]") + str(']') <'phi::syntax::parse_class';
my $parse_atom     = $ws*0 + ($string | $parse_class | $word | $parse_parens) + $ws*0 <'phi::syntax::atom';

my $parse_unary    = $parse_atom + (str"+" <'phi::syntax::blue_op') + $ws*0 <'phi::syntax::parse_rep1'
                   | $parse_atom + (str"*" <'phi::syntax::blue_op') + $ws*0 <'phi::syntax::parse_rep0'
                   | $parse_atom;

$parse_expr_ref->set($parse_unary + (str"|" <'phi::syntax::blue_op') + $parse_expr <'phi::syntax::parse_alt'
                   | $parse_unary + $parse_expr <'phi::syntax::parse_seq'
                   | $parse_unary);

my $parse_assign = $atom + (str"::=" <'phi::syntax::special_op') + $parse_expr
                   <'phi::syntax::parse_assign';

$expr_ref->set($parse_assign | $binop | $atom);


# Editor setup
use constant e => phi::editor::buffer->new(<<'EOF');
#!/usr/bin/env phi
# some conditional stuff
x.iftrue {
  y = 10;
  z = (y + 3 >> 6).to_f;
};

syntax ::= foo | "bar"+ [a-z];
foo    ::= [1-9] [0-9]*;

path = /bin/ls;
path.size.print;

# status update
xs = [1, 2, 3];
xs.each { (_ + 1).print };
print "done";

exit 0;
EOF

use constant c => phi::editor::cursor->new(e);


package phi::syntax::node
{
  use overload qw/"" explain/;

  sub print_at
  {
    my $self = shift;
    my $pos  = shift;
    my ($r, $c) = map $_+1, phi::e->pos_rowcol($pos);
    print "\033[$r;${c}H", @_;
  }

  sub print
  {
    my $self = shift;
    $self->print_at($$self{output}->start, @_);
  }

  sub colored
  {
    my ($self, $c) = @_;
    $self->print("\033[${c}m$$self{val}");
  }

  sub explain { shift->{output}->explain }
}


{
  no strict 'refs';
  push @{"phi::syntax::${_}::ISA"}, 'phi::syntax::node'
    for qw/ expr program atom binop whitespace op number word path string list
            parens block line_comment delimiter shebang

            parse_expr parse_class parse_rep1 parse_rep0 parse_alt parse_seq
            special_op blue_op
            /;
}


# Syntax rendering
sub phi::syntax::expr::render { ${+shift}->render }
sub phi::syntax::program::render
{
  my ($es, $w) = @{+shift};
  $$_->render for @$w, map $$_[0], @$es;
  $$_->render for map @{$$_[0]}, @$es;
}

sub phi::syntax::atom::render
{
  my ($ws1, $atom, $ws2) = map $_->val, @{shift->{val}};
  $_->val->render for @$ws1, @$ws2;
  $atom->render;
}

sub phi::syntax::binop::render
{
  my ($l, $ops) = map $_->val, @{shift->{val}};
  $l->render;
  for (@$ops)
  {
    $_->val->render, next unless ref $_->val eq 'ARRAY';
    $_->val->render for @{$_->val};
  }
}

sub phi::syntax::whitespace::render {}

sub phi::syntax::delimiter::render { shift->colored('0;37') }
sub phi::syntax::op::render        { shift->colored('0;32') }
sub phi::syntax::number::render    { shift->colored('0;31') }
sub phi::syntax::word::render      { shift->colored('0;30') }
sub phi::syntax::path::render      { shift->colored('0;35') }

sub phi::syntax::string::render
{
  my ($self) = @_;
  $self->print("\033[0;31m" . (e->substr($$self{output}->start,
                                         $$self{output}->length)
                               =~ s/\n/\r\n/gr));
}

sub phi::syntax::list::render
{
  my ($self) = @_;
  my ($open, $xs, $close) = map $_->val, @{$$self{val}};
  $open->render;
  $close->render;
  for (@$xs)
  {
    $_->val->[0]->val->render;
    $_->val->render for @{$_->val->[1]->val};
  }
}

sub phi::syntax::parens::render { $_->val->render for @{shift->{val}}; }
sub phi::syntax::block::render  { $_->val->render for @{shift->{val}}; }

sub phi::syntax::line_comment::render
{
  my ($self) = @_;
  $self->print("\033[3;34m", map $_->val, @{$$self{val}});
}

sub phi::syntax::shebang::render
{
  my ($self) = @_;
  $self->print("\033[3;32m", map $_->val, @{$$self{val}});
}


sub phi::syntax::special_op::render { shift->colored('1;34') }
sub phi::syntax::blue_op::render    { shift->colored('1;35') }
sub phi::syntax::parse_expr::render { shift->{val}->render }
sub phi::syntax::parse_rep1::render { $_->val->render for @{shift->{val}}[0, 1] }
sub phi::syntax::parse_rep0::render { $_->val->render for @{shift->{val}}[0, 1] }
sub phi::syntax::parse_alt::render  { $_->val->render for @{shift->{val}} }
sub phi::syntax::parse_seq::render  { $_->val->render for @{shift->{val}} }
sub phi::syntax::parse_assign::render { $_->val->render for @{shift->{val}} }

sub phi::syntax::parse_class::render
{
  my ($self) = @_;
  $self->print_at($$self{output}->start + 1,
                  "\033[0;35m" . (e->substr($$self{output}->start + 1,
                                            $$self{output}->length - 2)
                                  =~ s/\n/\r\n/gr));

  $self->print_at($$self{output}->start,   "\033[0;32m[");
  $self->print_at($$self{output}->end - 1, "\033[0;32m]");
}


use JSON;
use constant je => JSON->new->allow_nonref(1)->convert_blessed(1);

use List::Util qw/min/;

system 'stty raw; stty -echo isig -ignbrk -brkint -ixon -ixoff';

my $parsed = $program->on(e);
my $ibuf = '';
while (read STDIN, $ibuf, 1, length $ibuf)
{
  $ibuf = substr $ibuf, 1 if $ibuf =~ /^\033/ && length $ibuf > 4;

  my $orig_pos = c->pos;

  c->col(0)  while $ibuf =~ s/^\033\[7~//;
  c->col(-1) while $ibuf =~ s/^\033\[8~//;
  c->move($1 eq 'A' ? -1 : $1 eq 'B' ? 1 : 0,
          $1 eq 'D' ? -1 : $1 eq 'C' ? 1 : 0)
    while $ibuf =~ s/^\033\[([ABCD])//;

  my $should_reparse = 0;

  c->backspace(c->col || 1), $should_reparse = 1 while $ibuf =~ s/^\x15//;
  c->backspace             , $should_reparse = 1 while $ibuf =~ s/^\x7f//;
  c->delete                , $should_reparse = 1 while $ibuf =~ s/^\033\[3~//;

  c->insert("  "), $should_reparse = 1 while $ibuf =~ s/^\t//;
  c->insert("\n"), $should_reparse = 1 while $ibuf =~ s/^\r//;
  c->insert($1)  , $should_reparse = 1 while $ibuf =~ s/^([^\033\x7f\x15]+)//;

  my $pos = c->pos;
  my ($row, $col) = c->rowcol;

  if ($should_reparse)
  {
    my $output = $parsed->parse(min($orig_pos, $pos));
    for my $l (0..$ENV{LINES} - 1)
    {
      my $r = $l + 1;
      print "\033[$r;1H\033[K\033[0;0m" . (e->line($l) // '');
    }

    my $last_r = e->lines + 1;
    #print "\033[$last_r;1H\033[K\033[0;37m" . $output->explain;

    $output->val->render;
  }

  my ($r, $c) = c->rowcol;
  $r++;
  $c++;
  print "\033[$r;${c}H";
}

system 'reset';
