#!/usr/bin/env perl
use strict;
use warnings;

no warnings 'precedence';

use Carp;

BEGIN
{
  $SIG{__DIE__} = sub { system 'stty sane'; Carp::confess(@_); system 'reset' };
  require 'parser.pm';
  require 'parsestr.pm';
  require 'parseapi.pm';
  require 'editor.pm';
}


package phi;

sub str($) { phi::parser::strconst->new(shift) }

sub oc { phi::parser::strclass->one_of(@_) }
sub mc { phi::parser::strclass->many_of(@_) }
sub oe { phi::parser::strclass->one_except(@_) }
sub me { phi::parser::strclass->many_except(@_) }

sub as($) { eval "#line 1 \"as(phi::syntax::$_[0])\"
                  sub {bless [\@_], 'phi::syntax::$_[0]'}" }


# Grammar definitions
my $expr_ref    = phi::parser::forward->new;
my $program_ref = phi::parser::forward->new;

my $expr    = $expr_ref    >>as"expr";
my $program = $program_ref >>as"program";

my $ws     = str('#!') + me("\n") >>as"shebang"
           | str('#') + me("\n")  >>as"line_comment"
           | str('#')             >>as"delimiter"
           | mc(" \n\r\t")        >>as"whitespace";

my $number = mc('0'..'9') >>as"number";

my $word   = mc('a'..'z',
                'A'..'Z',
                '0'..'9', '_') >>as"word";

my $path   = mc('-/_.+', 'a'..'z', 'A'..'Z', 0..9) >>as"path";
my $op     = (mc('+-*/|&^%!~:.=<>?') | str(""))    >>as"op";

my $string = (str('"') + (me("\\\"") | str("\\") + oe('')) + str('"'))
             >>as"string";

my $list   = ((str("[") >>as"delimiter")
              + ($expr + (str(",") >>as"delimiter")*0)*0
              + (str("]") >>as"delimiter"))
             >>as"list";

my $parens = (str("(") >>as"delimiter")
             + $expr
             + (str(")") >>as"delimiter")
             >>as"parens";

my $block  = (str("{") >>as"delimiter")
             + $program
             + (str("}") >>as"delimiter")
             >>as"block";

my $atom  = $ws * 0
            + ($parens | $block | $number | $list | $string | $word | $path)
            + $ws * 0
            >>as"atom";
my $binop = ($atom + ($op + $atom | $atom) * 1) >>as"binop";

$expr_ref->set($binop | $atom);
$program_ref->set(($expr + (str(';') >>as"delimiter")*0) * 0
                  + $ws * 0);


# Parser sub-language
my $parse_expr_ref = phi::parser::forward->new;
my $parse_expr     = $parse_expr_ref >>as"parse_expr";
my $parse_parens   = (str('(') >>as"delimiter")
                   + $parse_expr
                   + (str(')') >>as"delimiter")
                   >>as"parens";

my $parse_class    = str('[') + me("\\]") + str(']')
                     >>as"parse_class";

my $parse_atom     = $ws*0 + ($string | $parse_class | $word | $parse_parens) + $ws*0
                     >>as"atom";

my $parse_unary    = $parse_atom + (str("+") >>as"blue_op") + $ws*0 >>as"parse_rep1"
                   | $parse_atom + (str("*") >>as"blue_op") + $ws*0 >>as"parse_rep0"
                   | $parse_atom;

$parse_expr_ref->set($parse_unary + (str("|") >>as"blue_op") + $parse_expr >>as"parse_alt"
                   | $parse_unary + $parse_expr >>as"parse_seq"
                   | $parse_unary);

my $parse_assign = $atom + (str("::=") >>as"special_op") + $parse_expr
                   >>as"parse_assign";

$expr_ref->set($parse_assign | $binop | $atom);


# Editor setup
use constant e => phi::editor::buffer->new(<<'EOF');
#!/usr/bin/env phi
# some conditional stuff
x.iftrue {
  y = 10;
  z = (y + 3 >> 6).to_f;
};

syntax ::= foo | "bar"+ [a-z];
foo    ::= [1-9] [0-9]*;

path = /bin/ls;
path.size.print;

# status update
xs = [1, 2, 3];
xs.each { (_ + 1).print };
print "done";

exit 0;
EOF

use constant c => phi::editor::cursor->new(e);


package phi::syntax::node
{
  sub print_at
  {
    my $self = shift;
    my $pos  = shift;
    my ($r, $c) = map $_+1, phi::e->pos_rowcol($pos);
    print "\033[$r;${c}H", @_;
  }

  sub print
  {
    my $self = shift;
    $self->print_at($self->result->start, @_);
  }

  sub colored
  {
    my ($self, $c) = @_;
    $self->print("\033[${c}m" . $self->val);
  }

  sub val    { shift->[0] }
  sub result { shift->[1] }
}


{
  no strict 'refs';
  push @{"phi::syntax::${_}::ISA"}, 'phi::syntax::node'
    for qw/ expr program atom binop whitespace op number word path string list
            parens block line_comment delimiter shebang

            parse_expr parse_class parse_rep1 parse_rep0 parse_alt parse_seq
            special_op blue_op parse_assign
            /;
}


# Syntax rendering
sub phi::syntax::expr::render { shift->val->render }
sub phi::syntax::program::render
{
  my ($es, $w) = @{shift->val};
  $_->render for @$w, map $_->[0], @$es;
}

sub phi::syntax::atom::render
{
  my ($ws1, $atom, $ws2) = @{shift->val};
  $_->render for @$ws1, @$ws2;
  $atom->render;
}

sub phi::syntax::binop::render
{
  local $_;
  my ($l, $ops) = @{shift->val};
  $l->render;
  for (@$ops)
  {
    $_->render, next unless ref eq 'ARRAY';
    $_->render for @$_;
  }
}

sub phi::syntax::whitespace::render {}

sub phi::syntax::delimiter::render { shift->colored('0;37') }
sub phi::syntax::op::render        { shift->colored('0;32') }
sub phi::syntax::number::render    { shift->colored('0;31') }
sub phi::syntax::word::render      { shift->colored('0;30') }
sub phi::syntax::path::render      { shift->colored('0;35') }

sub phi::syntax::string::render
{
  my ($self) = @_;
  $self->print("\033[0;31m" . (e->substr($self->result->start,
                                         $self->result->length)
                               =~ s/\n/\r\n/gr));
}

sub phi::syntax::list::render
{
  my ($self) = @_;
  my ($open, $xs, $close) = @{$self->val};
  $open->render;
  $close->render;
  for (@$xs)
  {
    $_->[0]->render;
    $_->render for @{$$_[1]};
  }
}

sub phi::syntax::parens::render { $_->render for @{shift->val}; }
sub phi::syntax::block::render  { $_->render for @{shift->val}; }

sub phi::syntax::line_comment::render
{
  my ($self) = @_;
  $self->print("\033[3;34m", @{$self->val});
}

sub phi::syntax::shebang::render
{
  my ($self) = @_;
  $self->print("\033[3;32m", @{$self->val});
}


sub phi::syntax::special_op::render   { shift->colored('1;34') }
sub phi::syntax::blue_op::render      { shift->colored('1;35') }
sub phi::syntax::parse_expr::render   { shift->val->render }
sub phi::syntax::parse_rep1::render   { $_->render for @{shift->val}[0, 1] }
sub phi::syntax::parse_rep0::render   { $_->render for @{shift->val}[0, 1] }
sub phi::syntax::parse_alt::render    { $_->render for @{shift->val} }
sub phi::syntax::parse_seq::render    { $_->render for @{shift->val} }
sub phi::syntax::parse_assign::render { $_->render for @{shift->val} }

sub phi::syntax::parse_class::render
{
  my ($self) = @_;
  $self->print_at($self->result->start + 1,
                  "\033[0;35m" . (e->substr($self->result->start + 1,
                                            $self->result->length - 2)
                                  =~ s/\n/\r\n/gr));

  $self->print_at($self->result->start,   "\033[0;32m[");
  $self->print_at($self->result->end - 1, "\033[0;32m]");
}

use Time::HiRes qw/time/;
use JSON;
use constant je => JSON->new->allow_nonref(1)->convert_blessed(1);

use List::Util qw/min/;

system 'stty raw; stty -echo isig -ignbrk -brkint -ixon -ixoff';

my $parsed = $program->on(e);
my $ibuf = '';
while (read STDIN, $ibuf, 1, length $ibuf)
{
  $ibuf = substr $ibuf, 1 if $ibuf =~ /^\033/ && length $ibuf > 4;

  my $orig_pos = c->pos;

  c->col(0)  while $ibuf =~ s/^\033\[7~//;
  c->col(-1) while $ibuf =~ s/^\033\[8~//;
  c->move($1 eq 'A' ? -1 : $1 eq 'B' ? 1 : 0,
          $1 eq 'D' ? -1 : $1 eq 'C' ? 1 : 0)
    while $ibuf =~ s/^\033\[([ABCD])//;

  my $should_reparse = 0;

  c->backspace(c->col || 1), $should_reparse = 1 while $ibuf =~ s/^\x15//;
  c->backspace             , $should_reparse = 1 while $ibuf =~ s/^\x7f//;
  c->delete                , $should_reparse = 1 while $ibuf =~ s/^\033\[3~//;

  c->insert("  "), $should_reparse = 1 while $ibuf =~ s/^\t//;
  c->insert("\n"), $should_reparse = 1 while $ibuf =~ s/^\r//;
  c->insert($1)  , $should_reparse = 1 while $ibuf =~ s/^([^\033\x7f\x15]+)//;

  my $pos = c->pos;
  my ($row, $col) = c->rowcol;

  if ($should_reparse)
  {
    my $t0     = time;
    my $output = $parsed->parse(min($orig_pos, $pos))->val;
    my $dt     = time - $t0;
    my $bytes  = length e->substr(min($orig_pos, $pos), e->length);
    my $mb_s   = $bytes / 1048576 / $dt;

    for my $l (0..$ENV{LINES} - 1)
    {
      my $r = $l + 1;
      print "\033[$r;1H\033[K\033[0;0m" . (e->line($l) // '');
    }

    my $last_r = e->lines + 1;
    print "\033[$last_r;1H\033[K\033[0;37m$dt = $mb_s MB/s";

    $output->render;
  }

  my ($r, $c) = c->rowcol;
  $r++;
  $c++;
  print "\033[$r;${c}H";
}

system 'reset';
