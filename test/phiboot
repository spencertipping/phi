#!/usr/bin/env perl
use strict;
use warnings;

package phi;
use phiboot;

use List::Util;
use Time::HiRes qw/time/;

sub l { list map ref ? $_ : pint $_, @_ }

# Compile-time macros
sub lit($)  { (l(shift), 0x06, l(2, 0), 0x06, 0x07) }
sub dup()   { (l(0, 0),       0x06, 0x07) }
sub drop()  { (l(1),          0x06, 0x07) }
sub swap()  { (l(2, 1, 0),    0x06, 0x07) }
sub rot3l() { (l(3, 2, 0, 1), 0x06, 0x07) }
sub rot3r() { (l(3, 1, 2, 0), 0x06, 0x07) }

sub if_()   { (rot3l, 0x1a, 0x1a, pnil, swap, 0x05, lit 2, 0x07, 0x02) }

# Resolver boot
our $resolver_code = pmut;
our $resolver_fn =
  l dup, 0x03, lit psym 'nil', 0x27,
    l(drop),
    l(0x06, 0x06, l(3, 3, 0, 1, 2), 0x06, 0x07, 0x27,
      l(l(3, 0), 0x06, 0x07),
      pcons(l(drop), pcons(pint 0x02, $resolver_code)),
      if_),
    if_;

$resolver_code->set($resolver_fn);

sub resolver
{
  my $l = pnil;
  while (@_)
  {
    my ($k, $v) = (shift, shift);
    $l = pcons pcons(psym $k, $v), $l;
  }
  pcons $l, $resolver_fn;
}

# Test code
sub test
{
  my $method = $_[0] eq 'trace' ? shift : 'run';
  my $ilist = l @_;
  my $st = time;
  my $i  = phi::i->new->push($ilist)->i2->$method;
  my $dt = 1000 * (time - $st);
  printf "%.2fms: %s\n", $dt, $$i[0];
}

test lit 1, lit 2, 0x10, 0x00, 0x03, 0x26, 0x21, 0x12;
test lit 4, 0x20, lit 0, lit 65, 0x23,
                  lit 1, lit 66, 0x23,
                  lit 2, lit 67, 0x23,
                  lit 3, lit 33, 0x23;

test lit 0, l(lit 1), l(lit 2), if_;
test lit 1, l(lit 1), l(lit 2), if_;

test resolver(k1 => l(lit 1)), 0x0b, psym 'k1';
test resolver(if => l(if_)), 0x0b,
     lit 0, l(lit 1), l(lit 2), psym 'if';

test resolver(if => l(if_),
              k0 => l(lit 0),
              k1 => l(lit 1),
              k2 => l(lit 2)), 0x0b,
     psym 'k0', l(psym 'k1'), l(psym 'k2'), psym 'if';

# xs [f] map
# xs [f]     swap dup = [f] xs xs
# [f] xs xs  is_nil   = [f] xs <1|0>
# [f] xs <1|0> [...] [...] if
#
# nil case:
# [f] xs     swap drop             = xs
#
# non-nil case:
# [f] x:xs   uncons                = [f] xs x
# [f] xs x   [2 0 1 2] 3 restack . = [f] xs x [f] .
# [f] xs fx  rot3>                 = fx [f] xs
# fx [f] xs  swap map swap cons    = fx:(map [f] xs)

test resolver(if     => l(if_),
              swap   => l(swap),
              drop   => l(drop),
              dup    => l(dup),
              is_nil => l(0x03, lit(psym 'nil'), 0x27),
              map    => l(psym 'swap',
                          psym 'dup',
                          psym 'is_nil',
                          l(psym 'swap', psym 'drop'),
                          l(0x06, l(3, 2, 0, 1, 2), 0x06, 0x07, 0x02,
                            rot3r, psym 'swap', psym 'map', psym 'swap', 0x05),
                          psym 'if')), 0x0b,
     l(1, 2, 3),
     l(lit(1), 0x10),
     psym 'map';

# optimized version
test resolver(map => l(swap, dup, 0x03, lit(psym 'nil'), 0x27,
                       l(swap, drop),
                       l(0x06, l(3, 2, 0, 1, 2), 0x06, 0x07, 0x02,
                         rot3r, swap, psym 'map', swap, 0x05),
                       if_)), 0x0b,
     l(1, 2, 3),
     l(lit(1), 0x10),
     psym 'map';
