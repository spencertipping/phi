#!/usr/bin/env perl
use strict;
use warnings;

use phiboot;
use phibootmacros;
use phiparse;

use List::Util;
use Time::HiRes qw/time/;

# Test code
sub test
{
  my $method = $_[0] eq 'trace' ? shift : 'run';
  my $ilist = l @_;
  my $st = time;
  my $i  = phiboot::i->new->push($ilist)->i2->$method;
  my $dt = 1000 * (time - $st);
  printf "%.2fms: %s\n", $dt, $$i[0];
}

use constant foostr => l pstr "foo", pint 0, pstr "xs";

# base tests
test lit 0, lit 1, i_lt;
test lit 1, lit 0, i_lt;

test lit 0, pstr "abc", i_sget;

# rev tests
test l(1, 2, 3),    phiparse::rev, i_eval;
test l(1, l(2, 3)), phiparse::rev, i_eval;
test pnil,          phiparse::rev, i_eval;

# parser test setup
use constant parse_success  => l lit(1), i_plus, dup;
use constant parse_success2 => l lit(2), i_plus, dup;
use constant parse_fail     => l drop, pstr "parse fail", pnil;
use constant parse_fail2    => l drop, pstr "parse fail2", pnil;

test lit(1), parse_success, i_eval;
test lit(1), parse_fail,    i_eval;

print "seq tests\n";
test lit(1), l(parse_success, parse_success),                phiparse::seq, i_eval;
test lit(1), l(parse_success, parse_success, parse_success), phiparse::seq, i_eval;
test lit(1), l(parse_success, parse_fail),                   phiparse::seq, i_eval;

print "rep tests\n";
test lit(1), parse_fail, phiparse::rep, i_eval;

test l(pstr "aaaabbbbc", pint 0, pstr "rest"), l(pstr "a", phiparse::str, i_eval), phiparse::rep, i_eval;
test l(pstr "aaaabbbbc", pint 0, pstr "rest"), l(pstr "b", phiparse::str, i_eval), phiparse::rep, i_eval;

print "alt tests\n";
test lit(1), l(parse_success, parse_success2), phiparse::alt, i_eval;
test lit(1), l(parse_fail,    parse_success2), phiparse::alt, i_eval;
test lit(1), l(parse_fail,    parse_fail),     phiparse::alt, i_eval;

print "flatmap tests\n";
test lit(0), parse_success,
             l(pnil, swap, i_cons, swap, i_cons),
             l(drop, parse_success2),
             phiparse::flatmap, i_eval;

test lit(0), parse_success,
             l(i_plus),
             l(drop, parse_success2),
             phiparse::flatmap, i_eval;

test lit(0), parse_success,
             l(i_plus),
             l(drop, parse_fail),
             phiparse::flatmap, i_eval;

test lit(0), parse_fail,
             l(i_plus),
             l(drop, parse_fail2),
             phiparse::flatmap, i_eval;

# aw yeah: using a parse result to repeat the parser
test l(pstr "foofoo", pint 0, pstr "xs"),
     l(pstr "foo", phiparse::str, i_eval),
     l(pnil, swap, i_cons, swap, i_cons),
     l(pnil, swap, i_cons, phiparse::str, i_cons,
       lit i_eval, i_cons, phiparse::rev, i_eval),
     phiparse::flatmap, i_eval;

print "str tests\n";
test foostr, pstr "f",  phiparse::str, i_eval;
test foostr, pstr "fo", phiparse::str, i_eval;
test foostr, pstr "fp", phiparse::str, i_eval;

test l(pstr "foobar", pint 3, pstr "xs"), pstr "bar", phiparse::str, i_eval;

print "contains tests\n";
test pstr "abc", lit 97, phiparse::contains, i_eval;
test pstr "abc", lit 96, phiparse::contains, i_eval;
test pstr "",    lit 96, phiparse::contains, i_eval;

print "oneof tests\n";
test l(pstr "", pint 0), pstr "f", lit 1, phiparse::oneof, i_eval;

test foostr, pstr "f",    lit 1, phiparse::oneof, i_eval;
test foostr, l(pstr "fo", lit 1, phiparse::oneof, i_eval),
     phiparse::rep, i_eval;

test foostr, l(pstr "of", lit 1, phiparse::oneof, i_eval),
     phiparse::rep, i_eval;

test foostr, l(pstr "ab", lit 0, phiparse::oneof, i_eval),
     phiparse::rep, i_eval;

test foostr, l(pstr "abo", lit 0, phiparse::oneof, i_eval),
     phiparse::rep, i_eval;

test foostr, l(pstr "abf", lit 0, phiparse::oneof, i_eval),
     phiparse::rep, i_eval;

test foostr, l(pstr "abfg", lit 1, phiparse::oneof, i_eval),
     phiparse::rep, i_eval;

print "map tests\n";
test foostr, l(drop, pstr "result"),
             l(pstr "f", phiparse::str, i_eval),
             phiparse::pmap, i_eval;

test foostr, l(i_slen),
             l(pstr "f", phiparse::str, i_eval),
             phiparse::pmap, i_eval;

test foostr, l(i_slen),
             l(pstr "abc", phiparse::str, i_eval),
             phiparse::pmap, i_eval;

print "filter tests\n";
test foostr, l(drop, lit 1),
             l(pstr "fo", phiparse::str, i_eval),
             phiparse::pfilter, i_eval;

test foostr, l(drop, lit 0),
             l(pstr "fo", phiparse::str, i_eval),
             phiparse::pfilter, i_eval;

test foostr, l(drop, lit 1),
             l(pstr "go", phiparse::str, i_eval),
             phiparse::pfilter, i_eval;
